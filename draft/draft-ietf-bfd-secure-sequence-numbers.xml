<?xml version="1.0" encoding="US-ASCII"?>
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="3"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<rfc
    category="exp"
    docName="draft-ietf-bfd-secure-sequence-numbers-latest"
    ipr="trust200902"
    submissionType="IETF"
    consensus="true">

  <front>
    <title abbrev="ISAAC Authentication">Meticulous Keyed ISAAC for
    BFD Optimized Authentication</title>

    <author fullname="Alan DeKok" initials="A" surname="Dekok">
      <organization>InkBridge Networks</organization>

      <address>
        <postal>
          <street>100 Centrepointe Drive #200</street>

          <city>Ottawa</city>

          <region>ON</region>

          <code>K2G 6B1</code>

          <country>Canada</country>
        </postal>

        <phone/>

        <facsimile/>

        <email>alan.dekok@inkbridge.io</email>

        <uri/>
      </address>
    </author>

    <author fullname="Mahesh Jethanandani" initials="M" surname="Jethanandani">
      <organization>Kloud Services</organization>

      <address>
        <postal>
          <street/>

          <city/>

          <region/>

          <code/>

          <country/>
        </postal>

        <phone/>

        <email>mjethanandani@gmail.com</email>

        <uri/>
      </address>
    </author>

    <author fullname="Sonal Agarwal" initials="S" surname="Agarwal">
      <organization>Cisco Systems, Inc</organization>

      <address>
        <postal>
          <street>170 W. Tasman Drive</street>

          <city>San Jose</city>

          <region>CA</region>

          <code>95070</code>

          <country>USA</country>
        </postal>

        <phone/>

        <facsimile/>

        <email>agarwaso@cisco.com</email>

        <uri>www.cisco.com</uri>
      </address>
    </author>

    <author fullname="Ashesh Mishra" initials="A" surname="Mishra">
      <organization>Aalyria Technologies</organization>

      <address>
        <postal>
          <street/>

          <city/>

          <region/>

          <code/>

          <country/>
        </postal>

        <phone/>

        <facsimile/>

        <email>ashesh@aalyria.com</email>

        <uri/>
      </address>
    </author>

    <author fullname="Jeffrey Haas" initials="J." surname="Haas">
      <organization>HPE</organization>
      <address>
        <email>jhaas@juniper.net</email>
      </address>
    </author>

    <date/>

    <abstract>
      <t>
	This document describes a BFD Optimized Authentication Mode,
	Meticulous Keyed ISAAC Authentication.  This mode can be used to
	authenticate some BFD packets with less CPU time cost than using
	MD5 or SHA1, with the tradeoff of decreased security.  This
	mechanism cannot be used to signal state changes, but it can
	be used to maintain a session in the Up state.
      </t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>
	<xref target="RFC5880" sectionFormat="parens"
	      section="6.7">BFD</xref> defines a number of authentication
	mechanisms, including Simple Password, and various other
	methods based on MD5 and SHA1 hashes.  The benefit of using
	cryptographic hashes is that they are secure.  The downside to
	cryptographic hashes is that they are expensive and time
	consuming on resource-constrained hardware.
      </t>

      <t>
	When BFD packets are unauthenticated, it is possible for an
	attacker to forge, modify, and/or replay packets on a link.
	These attacks have a number of side effects.  They can cause
	parties to believe that a link is down, or they can cause
	parties to believe that the link is up when it is, in fact,
	down.
      </t>
      <t>
	<xref target="I-D.ietf-bfd-optimizing-authentication"/> defines
	procedures that enable better scaling of authentication for BFD by
	splitting BFD authentication work between more computationally intensive
	authentication used for significant changes, and less computationally
	intensive authentication for packets validating that the session is in
	the Up state.  See that document for general performance and security
	considerations.
      </t>
      <t>
        This document provides the definition of BFD optimized authentication
	modes using the existing 
	MD5 (<xref target="RFC5880" section="6.7.3"/>) and
	SHA1 (<xref target="RFC5880" section="6.7.4"/>) authentication
	mechanisms for the more computationally intensive work.  It also defines
	methods for using a mechanism, <xref target="ISAAC">ISAAC</xref>, for
	the less computationally intensive mechanism.
      </t>

      <t>
	ISAAC requires only a few CPU
	operations per generated 32-bit number, can take a large
	secret key as a seed, and it has an extremely long cycle
        length.  These properties make it ideal for use in BFD.
      </t>

      <t>
	<xref target="ISAAC+">ISAAC+</xref> documents some cryptanalysis of the
	ISAAC mechanism.  This analysis addressed an issue with initial seeding,
	and the method proposed here incorporates recomendations to address
	that attack.
      </t>

      <section title="Meticulous Keying">
	<t>
	  <xref target="RFC5880">RFC5880</xref> uses the term
	  "meticulous keyed" and "meticulous keying" without
	  defining those terms.  That meaning of that term is found
	  by examining the definition of the Sequence Number from
	  <xref target="RFC5880" sectionFormat="parens"
		section="4.2">BFD</xref>:
	</t>

	<dl newline="true">
	  <dt>Sequence Number</dt>

	  <dd>
	    The sequence number for this packet.  For Keyed MD5
	    Authentication, this value is incremented occasionally.
	    For Meticulous Keyed MD5 Authentication, this value is
	    incremented for each successive packet transmitted for a
	    session.  This provides protection against replay
	    attacks.
	  </dd>
	</dl>

	<t>
	  In this context, the term "meticulous" means that the
	  Sequence number is incremented on every new packet which
	  is sent.  The term "keyed" means that the packets are
	  authenticated via the use of a secret key or keys which
	  are known to both sender and receiver.  The term
	  "meticulous keyed" therefore refers to BFD authentication
	  type where each subsequently transmitted packet has a sequence number
	  one greater than the immediately prior one, and can be authenticated.
	</t>
      </section>
      <section title="Requirements Language">
	<t>
	  The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
          "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT
          RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
          interpreted as described in BCP 14 <xref target="RFC2119"/>
          <xref target="RFC8174"/> when, and only when, they appear in
	  all capitals, as shown here.
	</t>
      </section>

      <section anchor="note-to-rfc-editor" title="Note to RFC Editor">
	<t>
	  This document uses several placeholder values throughout the
	  document. Please replace them as follows and remove this
	  note before publication.
	</t>

	<t>
	  RFC XXXX, where XXXX is the number assigned to this document
	  at the time of publication.
	</t>

	<t>
	  YYYY-MM-DD with the actual date of the publication of this
	  document.
	</t>
      </section>
    </section>

    <section title="Experimental updates to RFC 5880">
      <t>
	This document describes an experimental update to <xref
	target="RFC5880">BFD</xref>. This experiment is intended to
	provide additional insights into what happens when the
	authentication method defined in this document is used.
      </t>

      <t>
	This document is classified as Experimental and is not part of
	the IETF Standards Track. Implementations based on this
	document should not be considered as compliant with <xref
	target="RFC5880">BFD</xref> and should not assume
	interoperability with other implementations that conform to
	this document.
      </t>

      <t>
	Some of the state variables in <xref target="RFC5880"
	sectionFormat="parens" section="6.8.1">BFD</xref>, are related
	to the authentication type being used for a particular
	session.  However, the definitions given in <xref
	target="RFC5880">BFD</xref> are specific to Keyed MD5 or SHA1
	Authentication, which limit their utility for new
	authentication types. For the purpose of the experiment, this
	specification updates the definition of some of the state
	variables as given below.
      </t>

      <t>
	These updated definitions are entirely compatible with the
	definitions given in <xref target="RFC5880"
	sectionFormat="parens" section="6.8.1">BFD</xref>, and require
	no changes to existing configurations or
	implementations. Instead, the updated definitions clarify that
	the state variables apply to the current authentication type,
	no matter what it is.
      </t>

      <t>
	The text first updates the <xref target="RFC5880"/>
	definitions, and then defines a new authentication type which
	uses these updated definitions.
      </t>

      <t>These updated definitions also mean that Authentication
      Sections SHOULD include a Sequence Number field.  Where a
      Sequence Number is not used (as with Simple Password) the
      variables bfd.RcvAuthSeq and bfd.XmitAuthSeq MUST be set to
      zero.  Where an Authentication Section uses a meticulous keyed
      authentication type, it MUST include a Sequence Number
      field.</t>

      <dl newline="true">
	<dt>
	  bfd.AuthType:
	</dt>
	<dd>
	  <t>
	    The current authentication type in use for this session,
	    as defined in <xref target="RFC5880"
	    sectionFormat="parens" section="4.1">BFD</xref>, or zero
	    if no authentication is in use.
	  </t>

	  <t>
	    When using an authentication method implementing optimized authentication 
	    (<xref target="I-D.ietf-bfd-optimizing-authentication"/>),
	    packets which indicate a BFD significant change MUST use an authentication
	    method which provides for full packet integrity checks with the
	    more computationally intensive authentication method.  When the
	    bfd.SessionState value is Up, packets MAY use a less
	    computationally intensive authentication method such as Meticulous
	    Keyed ISAAC.
	  </t>
	</dd>

	<dt>
	  bfd.RcvAuthSeq:
	</dt>
	<dd>
	  A 32-bit unsigned integer containing the last sequence
	  number for the current Authentication Section that was
	  received and accepted.  The initial value is unimportant.
	</dd>

	<dt>
	  bfd.XmitAuthSeq:
	</dt>
	<dd>
	  A 32-bit unsigned integer containing the next sequence
	  number for the Authentication Section which will be
	  transmitted.  This variable MUST be initialized to a random
	  32-bit value.  This value SHOULD be taken from a
	  cryptographically strong pseudo-random number generator
	  (CSPRNG).
	</dd>

	<dt>
	  bfd.AuthSeqKnown:
	</dt>
	<dd>
	  <t>
	    Set to 1 if the next expected Authentication Section has a
	    sequence number which is known, or 0 if it is not known.
	    This variable MUST be initialized to zero.
	  </t>

	  <t>
	    This variable MUST be set to zero after no packets have
	    been received on this session for at least twice the
	    Detection Time.  This ensures that the sequence number can
	    be resynchronized if the remote system restarts.
	  </t>
	</dd>
      </dl>
    </section>

    <section title="Architecture of the Auth Type Method">
      <t>
	This document specifies two 
	<xref target="I-D.ietf-bfd-optimizing-authentication">Optimized BFD</xref>
	authentication modes:

	<ul>
	  <li>
	    For the more computationally intensive authentication mechanisms, the existing
	    MD5 (<xref target="RFC5880" section="6.7.3"/>) and
	    SHA1 (<xref target="RFC5880" section="6.7.4"/>) authentication
	    mechanisms are leveraged with small PDU changes necessary to carry the
	    Optimization Mode encoding.  These changes are documented in 
	    <xref target="md5 format"/> and <xref target="sha1 format"/>
	    respectively.
	  </li>
	  <li>
	    For the less computationally intensive authentication mode, this
	    document defines the Meticulous Keyed ISAAC Authentication mechanism.
	    The PDU format for this mode is defined in <xref target="meticulous_keyed_isaac"/>.
	    The procedures for using this format are covered later in this document.
	  </li>
	</ul>
      </t>

      <t>ISAAC is used as a way to generate an infinite stream of
      pseudo-random numbers, referred to here as "Auth Keys".  With
      Meticulous Keyed ISAAC Authentication, these Auth Keys are used
      as a signal that the sending party is authentic.  That is, only
      the sending party can generate the correct Auth Keys.  Therefore
      if the receiving party sees a correct Auth Key in a BFD Control Packet in
      the Up state, then only the sending party could have generated it.
      </t>

      <t>Note that BFD Control Packets with the less computationally intensive
      ISAAC authentication format type are NOT signed or authenticated.  Therefore, 
      this format MUST NOT be used to signal BFD state
      changes.
      </t>

      <section title="Rationale for ISAAC and Operational Overview">
	<t>
	  There are many CSPRNGs available. This section explains why ISAAC was chosen.
	</t>

	<t>
	  The goal for this less computationally intensive authentication was to provide a
	  signal that the session was in the Up state, in the
	  form of a 32-bit number which is difficult for an attacker
	  to guess.  The number should be generated from a CSPRNG
	  which produces results based on a seed composed of both
	  public and private data.  Since BFD can have packet loss,
	  the generator should also be "seekable", in that the BFD
	  state machine should be able to query the generator (within
	  a small window) for new numbers.
	</t>

	<t>
	  This last property rules out most CSPRNGs, as they are
	  not seekable by design.  That is, most CSRNGs maintain
	  minimal state, and are designed to produce a long sequence
	  of pseudo-random numbers from a few simple calculations.  In
	  general, every call to the CSPRNG function modifies the
	  internal state in an irreversible fashion, and then produces
	  a new random number as the result.
	</t>

	<t>
	  It could be possible to use such a generator, and then to
	  manually save many results in a buffer.  This buffer could
	  then enable "seeking" within a short window.  In contrast,
	  ISAAC produces large sets of numbers by design, making it
	  an integrated solution.
	</t>

	<t>
	  Further, most CSPRNGs are designed to have small seeds.
	  This limitation means that any secret key defined by an
	  administrator is not directly usable as a seed for the
	  generator.  Instead, any secret key (including any
	  per-session data) would have to be hashed before being used
	  to see the generator.  For these reasons, ISAAC was chosen. It
	  can accept keys up to 8192 octets in length, which is more
	  than sufficient for BFD.
	</t>

	<t>
	  ISAAC has been subject to cryptanalysis, most notably <xref
	  target="ISAAC+">ISAAC+</xref>.  There are no known
	  vulnerabilities.
	</t>

	<t>
	  An instance of ISAAC is created for transmission and one for
	  reception.  An instance is required for each direction since the
	  inputs for seeding ISAAC require the locally randomly generated Seed
	  value, and the current BFD Your Discriminator value for an Up session,
	  and these values are distinct on each side of the BFD session.
	</t>

	<t>
	  The process for using ISAAC with BFD for each direction is then as follows:

	  <ul>
	    <li>
	      The administrator provides a secret key which is used to
	      authenticate each party in the BFD sessions.
	    </li>
	    <li>
	      When the session transitions into the Up state, the
	      secret key is combined with per-session data to seed ISAAC.
	    </li>
	    <li>
	      The ISAAC process produces a "page" of 256 32-bit random
	      numbers.
	    </li>
	    <li>
	      The BFD state machine also records a Sequence Number
	      which is associated with the first entry of that page.
	      The combination of 256 entries and the Sequence number
	      allows the BFD state machine to "seek" within a
	      256-packet window with zero cost, through simple
	      addition or subtraction of Sequence Numbers.
	    </li>
	    <li>
	      If there is a lost packet, the BFD state machine
	      simply seeks to the entry which is associated with the
	      received packet, and checks if the received packet
	      contains the expected number.
	    </li>
	    <li>
	      BFD supports packet rates of hundreds of packets per
	      second.  Even at those rates, 256 entries per ISAAC
	      page provides for about a second of BFD operation
	      before the next page has to be calculated.
	    </li>
	    <li>
	      As the next page calculation is complex, and there is
	      a long period of time available before the next page
	      is needed, this calculation can be done in the background.
	    </li>
	    <li>
	      If the next page calculation is started immediately
	      after the current page is fully used, there should be
	      sufficient time to calculate the next page as a
	      background task, no matter what the packet rate.
	    </li>
	  </ul>

	  <t>
	    In summary, the ISAAC seed depends on both a secret key
	    and per-session data, so it is difficult for an attacker
	    to guess or attack via an off-line dictionary attack.
	    The generated numbers
	    are saved in an array, where the BFD fast path can
	    consume them at essentially zero cost.
	  </t>
	  <t>
	    The only downside to this method is that it does not
	    provide for per-packet integrity checks.  This limitation
	    is addressed by mandating that Meticulous Keyed ISAAC
	    Authentication is only used to signal that the session
	    remains in the Up state. The ISAAC numbers then signal
	    that the originator of the packet is authentic, and the
	    BFD state machine verifies that the rest of the packet
	    is well formed, and matches the expected state.
	  </t>

	  <t>
	    The result is an authentication method which satisfies
	    both the needs of the BFD state machine, and is secure.
	  </t>
	</t>
      </section>
    </section>

    <section title="Meticulous Keyed ISAAC Authentication Types">
      <section title="Meticulous Keyed ISAAC Authentication, ISAAC Format" anchor="meticulous_keyed_isaac">
	<t>
	  If the Authentication Present (A) bit is set in the header,
	  and the Authentication Type field contains either Optimized
	  MD5 Meticulous Keyed ISAAC Authentication (TBD1), or
	  Optimized SHA-1 Meticulous Keyed ISAAC Authentication
	  (TBD2), and the Optimized Authentication Mode field contains
	  2 (<xref target="I-D.ietf-bfd-optimizing-authentication"
	  section="7"/>) the Authentication Section has the following
	  format:
	</t>

	<figure title="Meticulous Keyed ISAAC Authentication Format" align="center">
	  <artwork><![CDATA[
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |   Auth Type   |   Auth Len    |  Auth Key ID  |   Opt. Mode   |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                        Sequence Number                        |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                             Seed                              |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                            Auth Key                           |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	  ]]></artwork>
	</figure>

	<dl newline="true">
	  <dt>
	    Auth Type:
	  </dt>
	  <dd>
	    The current Auth Type.  It MUST provide for meticulous
	    keying.  That is, an authentication type where each packet
	    is authenticated, and also where the Sequence Number field
	    is incremented by one (1) for every packet which is sent.
	  </dd>

	  <dt>
	    Auth Len:
	  </dt>
	  <dd>
	    The length of the Authentication Section, in bytes.  For
	    Meticulous Keyed ISAAC Authentication, the length is 16.
	  </dd>

	  <dt>
	    Auth Key ID:
	  </dt>
	  <dd>
	    The authentication key ID in use for this packet.  This
	    allows multiple secret keys to be active simultaneously.
	  </dd>

	  <dt>
	    Opt Mode:
	  </dt>
	  <dd>
	    The Optimized Authentication Mode is defined in 
	    <xref target="I-D.ietf-bfd-optimizing-authentication" section="7"/>.
	    When the Auth Type is either Optimized MD5 Meticulous Keyed ISAAC
            Authentication (TBD1), or Optimized SHA-1 Meticulous Keyed ISAAC
            Authentication (TBD2), and the format is Meticulous Keyed ISAAC
            Authentication Format, the Optimized Authentication Mode field will
            be set to 2.
	  </dd>

	  <dt>
	    Sequence Number:
	  </dt>
	  <dd>
	    The sequence number for this packet.  For Meticulous Keyed
	    ISAAC Authentication, this value is incremented once for
	    each successive packet transmitted for a session.  This
	    provides protection against replay attacks.
	  </dd>

	  <dt>
	    Seed:
	  </dt>
	  <dd>
	    A 32-bit (4 octet) seed which is used in conjunction with
	    the shared key in order to configure and initialize the
	    ISAAC pseudo-random-number-generator (PRNG).  It is used to
	    identify and secure different "streams" of random numbers
	    which are generated by ISAAC.
	  </dd>

	  <dt>
	    Auth Key:
	  </dt>
	  <dd>
	    <t>
	      This field carries the 32-bit (4 octet) ISAAC output which
	      is associated with the Sequence Number.  The ISAAC PRNG
	      MUST be configured and initialized as given in <xref
	      target="seeding-isaac"/>, below.
	    </t>
	    <t>
	      Note that the Auth Key here does not include any summary
	      or hash of the BFD Control Packet.  The packet itself is completely
	      unauthenticated.
	    </t>
	  </dd>
	</dl>
	<t>When the receiving party receives a BFD packet with an
	expected sequence number and the correct corresponding ISAAC
	output in the Auth Key field, it knows that only the authentic
	sending party could have sent that message.  The sending party is
	therefore Up, as it is the only one who could have sent the
	message.</t>
      </section>

      <section anchor="md5 format" title="Meticulous Keyed ISAAC Authentication, MD5 Format">
	<t>
	  If the Authentication Present (A) bit is set in the header,
	  and the Authentication Type field contains Optimized MD5
	  Meticulous Keyed ISAAC Authentication (TBD1), and the
	  Optimized Authentication Mode field contains 1 (<xref
	  target="I-D.ietf-bfd-optimizing-authentication"
	  section="7"/>) the Authentication Section has the following
	  format:
	</t>

	<figure title="Meticulous Keyed ISAAC Authentication, MD5 Format" align="center">
	  <artwork><![CDATA[
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |   Auth Type   |   Auth Len    |  Auth Key ID  |   Opt. Mode   |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                        Sequence Number                        |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                      Auth Key/Digest...                       |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                              ...                              |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

	  ]]></artwork>
	</figure>

	<dl newline="true">
	  <dt>
	    Auth Type:
	  </dt>
	  <dd>
	    The current Auth Type.  It MUST provide for meticulous
	    keying.  That is, an authentication type where each packet
	    is authenticated, and also where the Sequence Number field
	    is incremented by one (1) for every packet which is sent.
	  </dd>

	  <dt>
	    Auth Len:
	  </dt>
	  <dd>
	    The length of the Authentication Section, in bytes.  For
	    Meticulous Keyed ISAAC MD5 Authentication Format, the length is 24.
	  </dd>

	  <dt>
	    Auth Key ID:
	  </dt>
	  <dd>
	    The authentication key ID in use for this packet.  This
	    allows multiple secret keys to be active simultaneously.
	  </dd>

	  <dt>
	    Opt Mode:
	  </dt>
	  <dd>
	    The Optimized Authentication Mode is defined in 
	    <xref target="I-D.ietf-bfd-optimizing-authentication" section="7"/>.
	    When the Auth Type is either Optimized MD5 Meticulous Keyed ISAAC
            Authentication (TBD1), and the format is MD5 Authentication Format, 
            the Optimized Authentication Mode field will be set to 1.
	  </dd>

	  <dt>
	    Sequence Number:
	  </dt>
	  <dd>
	    The sequence number for this packet.  For Meticulous Keyed
	    ISAAC Authentication, this value is incremented once for
	    each successive packet transmitted for a session.  This
	    provides protection against replay attacks.
	  </dd>

	  <dt>
	    Auth Key/Digest:
	  </dt>
	  <dd>
	    This field carries the 16-byte MD5 digest for the packet.  
	    The procedure for calculating this field is documented in
	    <xref target="RFC5880" section="6.7.3"/>.
	  </dd>
	</dl>
      </section>

      <section anchor="sha1 format" title="Meticulous Keyed ISAAC Authentication, SHA1 Format">
	<t>
	  If the Authentication Present (A) bit is set in the header,
	  and the Authentication Type field contains Optimized SHA1
	  Meticulous Keyed ISAAC Authentication (TBD2), and the
	  Optimized Authentication Mode field contains 1 (<xref
	  target="I-D.ietf-bfd-optimizing-authentication"
	  section="7"/>) the Authentication Section has the following
	  format:
	</t>

	<figure title="Meticulous Keyed ISAAC Authentication, SHA1 Format" align="center">
	  <artwork><![CDATA[
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |   Auth Type   |   Auth Len    |  Auth Key ID  |   Opt. Mode   |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                        Sequence Number                        |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                       Auth Key/Hash...                        |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                              ...                              |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

	  ]]></artwork>
	</figure>

	<dl newline="true">
	  <dt>
	    Auth Type:
	  </dt>
	  <dd>
	    The current Auth Type.  It MUST provide for meticulous
	    keying.  That is, an authentication type where each packet
	    is authenticated, and also where the Sequence Number field
	    is incremented by one (1) for every packet which is sent.
	  </dd>

	  <dt>
	    Auth Len:
	  </dt>
	  <dd>
	    The length of the Authentication Section, in bytes.  For
	    Meticulous Keyed ISAAC SHA1 Authentication Format, the length is 28.
	  </dd>

	  <dt>
	    Auth Key ID:
	  </dt>
	  <dd>
	    The authentication key ID in use for this packet.  This
	    allows multiple secret keys to be active simultaneously.
	  </dd>

	  <dt>
	    Opt Mode:
	  </dt>
	  <dd>
	    The Optimized Authentication Mode is defined in 
	    <xref target="I-D.ietf-bfd-optimizing-authentication" section="7"/>.
	    When the Auth Type is either Optimized SHA1 Meticulous Keyed ISAAC
            Authentication (TBD1), and the format is SHA1 Authentication Format, 
            the Optimized Authentication Mode field will be set to 1.
	  </dd>

	  <dt>
	    Sequence Number:
	  </dt>
	  <dd>
	    The sequence number for this packet.  For Meticulous Keyed
	    ISAAC Authentication, this value is incremented once for
	    each successive packet transmitted for a session.  This
	    provides protection against replay attacks.
	  </dd>

	  <dt>
	    Auth Key/Digest:
	  </dt>
	  <dd>
	    This field carries the 16-byte SHA1 hash for the packet.  
	    The procedure for calculating this field is documented in
	    <xref target="RFC5880" section="6.7.4"/>.
	  </dd>
	</dl>
      </section>
    </section>

    <section title="New State variables for Meticulous Keyed ISAAC Authentications">
      <t>
	This document defines new state variables for use with
	Meticulous Keyed ISAAC Authentication.
      </t>

      <dl newline="true">
	<dt>
	  bfd.MetKeyIsaacRcvKeyKnown:
	</dt>
	<dd>
	  A boolean value which indicates whether or not the system
	  knows the receive key for the Meticulous Keyed ISAAC
	  Authentication.  The initial value is false.  This value
	  is changed to "true" when a party verifies that the other
	  party has started to use the Meticulous Keyed ISAAC
	  Authentication, with an authenticated Auth Key.
	</dd>

	<dt>
	  bfd.MetKeyIsaacRcvAuthBase:
	</dt>
	<dd>
	  A 32-bit unsigned integer containing a copy of the
	  bfd.RcvAuthSeq number which is associated with the current
	  ISAAC "page" for authenticating received packets.
	</dd>

	<dt>
	  bfd.MetKeyIsaacRcvAuthIndex:
	</dt>
	<dd>
	  An 8-bit number used to index within a particular "page" of
	  pseudo-random numbers.
	</dd>

	<dt>
	  bfd.MetKeyIsaacRcvAuthSeed:
	</dt>
	<dd>
	  A 32-bit unsigned integer containing a copy of the Seed
	  associated with received packets.
	</dd>

	<dt>
	  bfd.MetKeyIsaacRcvAuthData:
	</dt>
	<dd>
	  A data structure which contains the ISAAC data for the
	  received Auth Type method.  The format and contents of this
	  structure are implementation specific, and hold the internal
	  state of the ISAAC CSPRNG.
	</dd>

	<dt>
	  bfd.MetKeyIsaacXmitKeyKnown:
	</dt>
	<dd>
	  A boolean value which indicates whether or not the system
	  knows the xmit key for Meticulous Keyed ISAAC Authentication.
	  The initial value is false.  This value is
	  changed to "true" when a party starts to transmit using
	  Meticulous Keyed ISAAC Authentication.
	</dd>

	<dt>
	  bfd.MetKeyIsaacXmitAuthBase:
	</dt>
	<dd>
	  A 32-bit unsigned integer containing a copy of the
	  bfd.XmitAuthSeq number which is associated with the current
	  ISAAC "page" for authenticating sent packets.
	</dd>

	<dt>
	  bfd.MetKeyIsaacXmitAuthIndex:
	</dt>
	<dd>
	  An 8-bit number used to index within a particular "page" of
	  pseudo-random numbers.
	</dd>

	<dt>
	  bfd.MetKeyIsaacXmitAuthSeed:
	</dt>
	<dd>
	  A 32-bit unsigned integer containing a copy of the Seed
	  associated with sent packets.
	</dd>

	<dt>
	  bfd.MetKeyIsaacXmitAuthData:
	</dt>
	<dd>
	  A data structure which contains the ISAAC data for the
	  sending Auth Type method.  The format and contents of this
	  structure are implementation specific, and hold the internal
	  state of the ISAAC CSPRNG.
	</dd>
      </dl>
    </section>


    <section title="Procedures for BFD Authentication using Meticulous Keyed ISAAC, MD5 or SHA1 Formats">
      <t>
        The transmit and receive procedures utilize the additional procedures
	documented in
	<xref target="I-D.ietf-bfd-optimizing-authentication" section="7.1"/>.
      </t>
      <t>
        The authentication procedure for Meticulous Keyed ISAAC, MD5 Format is
	covered by <xref target="RFC5880" section="6.7.3"/> for the Meticulous
	Keyed MD5 Authentication mode.
      </t>
      <t>
        The authentication procedure for Meticulous Keyed ISAAC, SHA1 Format is
	covered by <xref target="RFC5880" section="6.7.4"/> for the Meticulous
	Keyed SHA1 Authentication mode.
      </t>
    </section>

    <section title="Procedures for BFD Authentication using Meticulous Keyed ISAAC, ISAAC Format">
      <t>In this mode of optimized authentication, one or more secret
      keys (with corresponding key IDs) are configured in each system.
      One of the keys is used to seed the ISAAC PRNG.  The output of
      ISAAC is used to signal that the sender is authentic.  To help
      avoid replay attacks, a sequence number is also carried in each
      packet.  For Meticulous Keyed ISAAC Authentication, the sequence number MUST be
      incremented by one on every packet.</t>

      <t>The receiving system accepts the packet if the key ID matches
      one of the configured Keys, and the Auth Key derived from the
      selected Key, Seed, and Sequence Number matches the Auth Key
      carried in the packet, and the sequence number is strictly
      greater than the last sequence number received (modulo wrap at
      2^32).  If any of these criteria do not match, the packet fails
      validation, and is discarded.</t>

      <t>
	Transmission Using Meticulous Keyed ISAAC Authentication, ISAAC Format
      </t>
      <list empty="true">
	<t>
	  The Auth Type field MUST be set to one of two values;
	  Optimized MD5 Meticulous Keyed ISAAC Authentication (TBD1); or
	  Optimized SHA-1 Meticulous Keyed ISAAC Authentication (TBD2).
	</t>
	<t>
          The Auth Len field MUST be set to 16.
	</t>
	<t>
          The Auth Key ID field
	  MUST be set to the ID of the current authentication key.
	  The Sequence Number field MUST be set to bfd.XmitAuthSeq.
	</t>

	<t>
	  The Seed field MUST be set to the value of the current seed
	  used for this session.
	</t>

	<t>
	  The Auth Key field MUST be set to the output of ISAAC, which
	  depends on the secret Key, the current Seed, and the
	  Sequence Number.
	</t>

	<t>
          The Optimized Authentication Mode field MUST be 2, the "less
          computationally intensive authentication type". See <xref
          target="I-D.ietf-bfd-optimizing-authentication"
          section="7"/>.
	</t>

	<t>
	  For Meticulous Keyed ISAAC Authentication, bfd.XmitAuthSeq MUST be
	  incremented by one on each packet, in a circular fashion (when
	  treated as an unsigned 32-bit value).  The bfd.XmitAuthSeq
	  MUST NOT be incremented by more than one per packet.
	</t>
      </list>

      <t>
	Receipt using Meticulous Keyed ISAAC Authentication, ISAAC Format
      </t>
      <list empty="true">
        <t>
          If the received BFD Control packet does not contain an Authentication
          Section, or the Auth Type is not correct (either Optimized MD5
          Meticulous Keyed ISAAC Authentication (TBD1) or Optimized SHA-1
          Meticulous Keyed ISAAC Authentication (TBD2)), then the received
          packet MUST be discarded.
        </t>

	<t>
	  If the Auth Key ID field does not match the ID of a
	  configured authentication key, the received packet MUST be
	  discarded.
	</t>

	<t>
          The Optimized Authentication Mode field MUST be 2, the "less
          computationally intensive authentication type". See <xref
          target="I-D.ietf-bfd-optimizing-authentication"
          section="7"/>.
	</t>

	<t>
	  If the Auth Len field is not equal to 16, the packet MUST be
	  discarded.
	</t>

	<t>
	  If bfd.AuthSeqKnown is 1, examine the Sequence Number field.
	  For Meticulous keyed ISAAC, if the sequence number lies
	  outside of the range of bfd.RcvAuthSeq+1 to
	  bfd.RcvAuthSeq+(3*Detect Mult) inclusive (when treated as an
	  unsigned 32-bit circular number space) the received packet
	  MUST be discarded.
	</t>

	<t>
	  If bfd.MetKeyIsaacRcvKeyKnown is "true" and the Seed field
	  does not match the current Seed value,
	  bfd.MetKeyIsaacRcvAuthSeed, the packet MUST be discarded.
	</t>

	<t>
	  Calculate the current expected output of ISAAC, which
	  depends on the secret Key, the current Seed, and the
	  Sequence Number.  If the value does not match the Auth Key
	  field, then the packet MUST be discarded.
	</t>

	<t>
	  If bfd.MetKeyIsaacRcvKeyKnown is false, the ISAAC related
	  variables are initialized as per <xref
	  target="receiver-variable-initialization"/> using the
	  contents of the packet.
	</t>

	<t>
	  Note that in some cases, calculating the expected output of
	  ISAAC will result in the creation of a new "page" of 256
	  numbers.  This process will be irreversible, and will
	  destroy the current "page".  As a result, if the generation
	  of a new output will create a new "page", the receiving
	  party MUST save a copy of the entire ISAAC state before
	  proceeding with this calculation.  If the outputs match,
	  then the saved copy can be discarded, and the new ISAAC
	  state is used.  If the outputs do not match, then the saved
	  copy MUST be restored, and the modified copy discarded, or
	  cached for later use.
	</t>
      </list>
    </section>

    <section title="Secret Key">
      <t>The security of the Meticulous Keyed ISAAC Auth Type depends on the Secret Key.
      The Secret Key is mixed with a per-session Seed as discussed
      below.  The result is used to initialize a stream of
      pseudo-random numbers using the ISAAC random number
      generator.</t>

      <t>A particular Secret Key is identified via the Auth Key ID
      field.  This Auth Key ID is either placed in the packet by the
      sender, or verified by the receiver.  Meticulous Keyed ISAAC
      Authentication permits systems to have multiple Secret
      Keys configured, but we do not discuss how those keys are
      managed or used.  A session MUST NOT, however,
      change the Auth Key ID for Meticulous Keyed ISAAC Authentication, during a
      session.  There is no defined way to re-sync or re-initialize an
      ongoing session with a different Auth Key ID and correspondingly
      different Secret Key.</t>

      <t>For interoperability, the management interface by which the
      key is configured MUST accept ASCII strings, and SHOULD also
      allow for the configuration of any arbitrary binary string in
      hexadecimal form.  Other configuration methods MAY be supported.</t>

      <t>The Secret Key MUST be at least eight (8) octets in length,
      and SHOULD NOT be more than 128 octets in length.</t>

      <t>There are no known issues with using the same secret Key for
      multiple Auth Type methods.  However, it is RECOMMENDED that
      administrators use different Secret Keys for each Auth Type.</t>
    </section>

    <section title="Transition to using ISAAC">
      <t>A BFD session which uses Optimized MD5 Meticulous Keyed ISAAC
      Authenticationo or Optimized SHA-1 Meticulous Keyed ISAAC Authentication 
      MUST begin a session with Auth Type set to the
      relevant authentication type, and the Optimized
      Authentication Mode field set to 1.
      </t>

      <t>
	When a BFD session using more computationally intensive authentication
	transitions to the Up state, the first Up packet MUST contain an
	Optimized Authentication Mode field with value 1.  Since state
	transitions require full packet integrity checks, an Optimized
	Authentication Mode field with value 2 is not
	permitted for state changes.  Each party MUST continue to use
	the more computationally intensive authentication mode until the other side has
	confirmed the switch to the Up state, with a packet that also
	uses more computationally intensive  authentication.
      </t>

      <t>
	Once the BFD session has transitioned to the Up state, the
	sender MAY send the subsequent packets for the Up
	state with the Optimized Authentication Mode field containing value
	2 using ISAAC format.
      </t>

      <t>When a system first receives a packet containing Optimized
      Authentication Mode field with value 2, it
      initializes the ISAAC PRNG state using the Seed from that packet.
      A system originating a packet using Meticulous Keyed ISAAC
      Authentication will generate a Seed, and place it into the
      packet which is then sent.  Further discussion of initialization
      is below in <xref target="sender-variable-initialization"/> and
      <xref target="receiver-variable-initialization"/>.</t>

      <t>The first packet after the transition to the Up state is the
      only time when the ISAAC random number generator for transmission is initialized.
      In contrast, a temporary transition away from using Meticulous
      Keyed ISAAC Authentication, ISAAC format (<xref target="transition-away"/>)
      and back, does not cause ISAAC to be re-keyed.</t>

      <t>There is no negotiation as to when authentication switches
      from the original type, to using Meticulous Keyed ISAAC Authentication
      using the ISAAC format.  The sender simply begins sending packets with a
      relevant Auth-Type,
      and with the Optimized Authentication Mode field set to 1.  When
      the sender switches to using using Meticulous Keyed ISAAC
      Authentication, ISAAC format, it sets the Optimized Authentication Mode field
      to 2, and starts performing the ISAAC calculations as described
      here.</t>

      <t>Similarly, a receiving system switches to using this method
      when it sees that it has received a packet contains Optimized
      Authentication Mode field set to 2 when
      bfd.MetKeyIsaacRcvKeyKnown variable is false.  The receiving
      system then initializes its variables, and authenticates the
      received packet, by comparing the Auth Key in the packet with
      the key it generated itself.</t>

      <t>The operation of those state variables MUST now satisfy
      the requirements of the new Optimized Authentication Mode.
      That is, when changing Optimized Authentication mode in a session, the current
      value of the bfd.RcvAuthSeq and bfd.XmitAuthSeq variables is
      used as the initial value(s) for the new mode.</t>
    </section>

    <section title="Seeding ISAAC" anchor="seeding-isaac">
      <t>The Seed field is used to identify and secure
      different "streams" of random numbers which are generated by
      ISAAC.  Each session uses a different Seed, which is used along
      with the Your Discriminator field
      (<xref target="RFC5880" section="4.1"/>),
      and the Secret Key, to initialize ISAAC.</t>

      <t>The value of the Seed field MUST be derived from a CSPRNG
      source.  Exactly how this can be done is outside of the scope of
      this document.</t>

      <t>A new Seed value MUST be created every time a BFD session
      transitions into the Up state.  In order to prevent continuous
      rekeying, once the session is in the Up state, the Seed for a
      session MUST NOT be changed until another state transition
      occurs.</t>

      <t>The ISAAC PRNG is initialized by setting all internal
      variables and data structures to zero (0).  The PRNG is then
      seeded by using the the following structure:</t>

      <t>
	<figure title="ISAAC Initialization Structure" align="center">
          <artwork><![CDATA[
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Seed                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Your Discriminator                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Secret Key ...            |  Counter |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	  ]]></artwork>
        </figure>
      </t>

      <t>
	Where the Your Discriminator field is taken from the BFD
	packet defined in <xref target="RFC5880">RFC5880 Section
	4.1</xref>.  This field is taken from the respective values
	used by a sending system.  For receiving systems, the field
	are taken from the received packet.  As the size of the buffer
	used to seed is limited, the length of the Secret Key MUST be
	no more than 1015 octets.  The Counter field is used to ensure
	the the initial seeding of ISAAC avoids the seeding issues
	discussed in <xref target="ISAAC+">ISAAC+</xref>.
      </t>

      <t>
	Whatever the API or other interface used to input the Secret
	Key, any implementation-specific internal representations of
	the Secret Key MUST NOT be used when encoding the Secret Key
	into the above data structure.  That is, there is no "length
	field which indicates how long the Secret Key is, and there is
	no trailing zero or NUL byte which indicates the end of the
	Secret Key.  Implementers are reminded that internal
	representations of data should not affect protocol
	operation.
      </t>

      <!-- XXX JMH - what size is the buffer?  We should state that here. -->
      <t>
	The buffer used to initialize ISAAC filled it with repeated
	copies of the above structure.  For each complete copy of the
	structure, the Counter field is incremented, starting from
	zero (0).  The final portion of the initialization buffer
	holds a partial copy of the structure, which is however much
	can be accommodated in the remaining portion of the buffer.
      </t>

      <t>
	Once the ISAAC "page" is initialized, the data is processed
	through the "randinit()" function of <xref
	target="ISAAC">ISAAC</xref>.  Pseudo-random numbers are then
	produced 32 bits at a time by calling the "isaac()" function.
      </t>

      <t>
	For the sender, this calculation can be done outside of the
	BFD "fast path" as soon as the Your Discriminator value is
	known.  For the receiver, this calculation can only be done
	when the Seed is received from the sender, and therefore the
	initial seeding needs to be done in the BFD "fast path".
      </t>

      <t>
	The following table gives Seed and Your Discriminator as
	32-bit hexadecimal values, and the Secret Key as an
	eleven-character string.  The subsequent table shows the first
	eight Sequence numbers and corresponding Auth Key values which
	were generated using the above initial values.
      </t>

      <figure title="Test Inputs for seeding ISAAC">
        <artwork><![CDATA[
	Field       Value(s)
	----------  ------------
	Seed        0x0bfd5eed
	Y-Disc      0x4002d15c
	Secret Key  RFC5880June
	Counter     0...50
	]]></artwork>
      </figure>


      <figure title="Expected Outputs">
        <artwork><![CDATA[
	Sequence Auth Key
	-------- --------
	0        9af65d83
	1        44355d56
	2        9334074e
	3        b643ef59
	4        74d659f1
	5        8966dc56
	6        a1f6f9bc
	7        21895a46
	]]></artwork>
      </figure>

      <t>
	This construct provides for 64 bits of entropy, of which 32
	bits is controlled by each party in a BFD session.  For
	security, each implemention SHOULD randomize their discrimator
	fields at the start of a session, as discussed in <xref
	target="RFC5880">Section 10</xref>.
      </t>

      <t>
	Note that this construct only uses the Your Discriminator
	field once, to seed ISAAC.  It therefore allows the My
	Discriminator field to change as permitted by <xref
	target="RFC5880" sectionFormat="parens"
	section="6.3">BFD</xref>.
      </t>

      <t>
	While the Your Discriminator field may change, there is no
	way to signal or negotiate Seed changes.  The Seed is set once
	by each party after the session transitions into the Up state,
	and then remains unchanged for the duration of the session.
	The receiving party MUST remember the current Seed value.  The
	Seed value MUST NOT change unless sending party has signalled
	a BFD state change with a packet that is authenticated using a
	more computationally intensive authentication method.  When a system receives a BFD
	packet containing Meticulous Keyed ISAAC Authentication, it
	MUST check that the received Seed contains the expected value,
	and if not, it MUST discard the packet as inauthentic.
      </t>

      <section title="Sender Variable Initialization"
	       anchor="sender-variable-initialization">
	<t>
	  A system which sends packets initializes ISAAC as described
	  above.  The ISAAC related variables are initialized as
	  follows:
	</t>

	<dl newline="true">
	  <dt>
	    bfd.MetKeyIsaacXmitKeyKnown:
	  </dt>
	  <dd>
	    This variable transitions from false to true when the
	    sender decides to start using ISAAC.  The sender also
	    initializes the other variables at the same time.
	  </dd>

	  <dt>
	    bfd.MetKeyIsaacXmitAuthBase:
	  </dt>
	  <dd>
	    The sender copies the bfd.XmitAuthSeq number from the
	    current packet to be sent into this variable.
	  </dd>

	  <dt>
	    bfd.MetKeyIsaacXmitAuthIndex:
	  </dt>
	  <dd>
	    The sender sets this variable to zero.
	  </dd>

	  <dt>
	    bfd.MetKeyIsaacXmitAuthSeed:
	  </dt>
	  <dd>
	    The sender copies the current Seed value into this
	    variable.  This variable is then copied into the "Seed"
	    field of each Auth Type packet.
	  </dd>

	  <dt>
	    bfd.MetKeyIsaacXmitAuthData:
	  </dt>
	  <dd>
	    The ISAAC state for sending is encapsulated in this
	    variable.
	  </dd>
	</dl>
      </section>

      <section title="Receiver Variable Initialization"
	       anchor="receiver-variable-initialization">
	<t>
	  When a system receives packets with Meticulous Keyed
	  ISAAC Authentication and is able to authenticate such a
	  packet the first time, the ISAAC related variables are
	  initialized as follows:
	</t>
	<dl newline="true">
	  <dt>
	    bfd.MetKeyIsaacRcvKeyKnown:
	  </dt>
	  <dd>
	    This variable transitions from false to true when the
	    receiver sees that the sender has started using Meticulous
	    Keyed ISAAC Authentication.  The receiver also initializes
	    the other variables at the same time.
	  </dd>

	  <dt>
	    bfd.MetKeyIsaacRcvAuthBase:
	  </dt>
	  <dd>
	    The bfd.RcvAuthSeq number from the current packet
	    is copied into this variable.
	  </dd>

	  <dt>
	    bfd.MetKeyIsaacRcvAuthIndex:
	  </dt>
	  <dd>
	    The receiver sets this value to zero
	  </dd>

	  <dt>
	    bfd.MetKeyIsaacRcvAuthSeed:
	  </dt>
	  <dd>
	    The receiver copies the Seed value from the received packet
	    into this variable.  Note that this copy only occurs when the
	    bfd.MetKeyIsaacXmitKeyKnown variable transitions from false
	    to true."
	  </dd>

	  <dt>
	    bfd.MetKeyIsaacRcvAuthData:
	  </dt>
	  <dd>
	    The ISAAC state for receiving is encapsulated in this
	    variable.
	  </dd>
	</dl>

	<t>
	  As there may be packet loss, the receiver has to take special
	  care to initialize the bfd.MetKeyIsaacRcvAuthBase variable.
	  If there has been no packet loss, the
	  bfd.MetKeyIsaacRcvAuthBase is taken directly from the
	  bfd.RcvAuthSeq variable, and the bfd.MetKeyIsaacRcvAuthIndex
	  is set to zero.
	</t>

	<t>
	  If, however, the packet's Sequence Number differs from the
	  expected value, then the difference "N" indicates how many
	  packets were lost.  The receiver then can use this
	  difference to index into the ISAAC page to find the
	  corresponding Auth Key.  If the key in the ISAAC page does
	  not match the corresponding Auth Key in the packets, the
	  packet fails validation, and is discarded.
	</t>

	<t>
	  If a key found by indexing into this ISAAC page 
          does match the Auth Key in the packet, then
	  the bfd.MetKeyIsaacRcvAuthIndex field is initialized to
	  this value.  The bfd.MetKeyIsaacRcvAuthBase field is then
	  initialized to contain the value of bfd.RcvAuthSeq, minus
	  the value of bfd.MetKeyIsaacRcvAuthIndex.  This process
	  allows the pseudo-random stream to be re-synchronized in the
	  event of lost packets.
	</t>

	<t>That is, the value for bfd.MetKeyIsaacRcvAuthBase is the
	Sequence Number for first Auth Key used in this session.  This
	value may be from a lost packet, but can never the less be
	calculated by the receiver from a later packet.</t>
      </section>

    </section>

    <section title="Operation">
      <t>Once the variables have been initialized, ISAAC will be able
      to produce 256 random numbers to use as Auth Keys, at near-zero
      cost.  The AuthIndex field is incremented by one for every new
      Auth Key generated.  Each new value of the Sequence Number field
      (sent or received) is then calculated by adding the relevant
      AuthBase and AuthIndex fields.</t>

      <t>When all 256 numbers are consumed the AuthIndex field will
      wrap to zero.  The ISAAC mixing function is then run, which then
      results in another set of 256 random numbers.  The AuthBase
      variable is then incremented by 256, to indicate that 256 Auth
      Keys have been consumed.  This process then continues until a
      BFD state change.</t>

      <t>ISAAC can be thought of here as producing an infinite stream
      of numbers, based on a secret key, where the numbers are
      produced in "pages" of 256 32-bit values.  This property of
      ISAAC allows for essentially zero-cost "seeking" within a page.
      The expensive operation of mixing is performed only once per 256
      packets, which means that most BFD packet exchanges can be fast
      and efficient.</t>

      <t>The receiving party can then look at the Sequence Number to
      determine which particular PRNG value is being used in the
      packet.  By subtracting the bfd.MetKeyIsaacAuthBase from the
      Sequence Number (with possible wrapping), an expected Index can be
      derived, and a corresponding Auth Key found.  This process thus permits
      the two parties to synchronize if/when a packet or packets are lost.</t>

      <t>Incrementing the Sequence Number for every packet also
      prevents the re-use of any individual pseudo-random number which
      was derived from ISAAC.</t>

      <t>The Sequence Number can increment without bounds, though it
      can wrap once it reaches the limit of the 32-bit counter field.
      ISAAC has a cycle length of 2^8287, so there is no issue with
      using more than 2^32 values from it.</t>

      <t>The result of the above operation is an infinite series of
      numbers which are unguessable, and which can be used to
      authenticate the sending party.</t>

      <t>Each system sending BFD packets chooses its own seed, and
      generates its own sequence of pseudo-random numbers using ISAAC,
      and place those values into the Auth Key field. Each system
      receiving BFD packets runs a separate pseudo-random number
      generator, and verifies that the received packets contain the
      expected Auth Key.</t>

      <section title="Page Flipping">
	<t>Once all 256 Auth Keys from the current page have been used,
	the next page is calculated by calling the isaac() function.
	This function modifies the current page to create the next
	page, and is inherently destructive.  In order to prevent
	issues, care should be taken to perform this process
	correctly.</t>

	<t>It is RECOMMENDED that implementations keep both a current
	page, and a next page associated with the ISAAC state.  The
	next can be calculated by making a copy of the current page,
	and then calling the isaac() function.</t>

	<t>The system needs to maintain the current page at all
	times when Meticulous Keyed ISAAC Authentication is used.  The
	next page does not need to be maintained at all times, and
	can be calculated on demand.  However, in order to avoid
	impacting the fast path, the next page should be calculated in
	the background in an asynchronous manner.</t>

	<t>This process has a number of benefits. First, At 60 packets
	per second, the system has approximately four (4) seconds of
	time to calculate the next page.  If the calculation is done
	quickly, the next page is available to the fast path before
	it is needed.</t>

	<t>Second, having the next page available early means that
	an attacker cannot spoof BFD packets, and force the received
	to spend significant resources calculating a next page on
	the BFD fast path.  Instead, the receiver can simply check
	the contents of the next page at near-zero cost, and discard
	the spoofed packet.</t>

	<t>When the receiver determines that it needs to move to the
	next page, it can simply swap the current and next pages
	(updating the BFD variables as appropriate), and then begin
	an asynchronous calculation of the next page.  Such
	asynchronous calculations are preferable to calculating the
	next page in the BFD fast path.</t>

	<t>This document does not make provisions for dealing with the
	case of losing more than 512 packets.  Implementors MUST limit
	the value of Detect Multi to a small enough number in order to keep
	the number of lost packets within an acceptable limit.</t>
      </section>

      <section title="Multiple Keys">
	<t>In a keyed algorithm, the key is shared between the two
	systems. Distribution of this key to all the systems at the same
	time can be quite a cumbersome task. BFD sessions running a fast
	rate may require these keys to be refreshed often, which poses
	a further challenge.</t>

	<t>While the Auth Key ID field provides for the provisioning of
	multiple keys simultaneously, there is no way within the BFD
	protocol for each party to signal which set of Key IDs are
	supported.  Any such signalling or negotiation needs to be done
	"out of band" for BFD, and usually via manual administrator
	configuration.</t>

	<t>The seeding mechanism for ISAAC, covered in 
	<xref target="seeding-isaac"/>, is carried out only once for a BFD
	session.  In order to rotate keys, it is REQUIRED to administratively
	disable the BFD session as part of changing the keys.  This permits the
	new session to be seeded as part of bringing up the new session.</t>
      </section>

    </section>

    <section title="Transition away from using ISAAC"
	     anchor="transition-away">
      <t>There are two ways to transition away from using ISAAC.  One
      way is via state changes: the link either goes down due to an
      fault, or one party signals a state change via a packet signed
      with a more computationally instensive  authentication.  The second
      situation is where one party wishes to temporarily signal via a more
      computationally intensive method that it is still Up,
      by setting the Optimized Authentication Mode field away from
      value 2 to value 1.</t>

      <t>The more computationally intensive authentication type provides for full packet
      integrity checks, which serves as a stronger indication that the
      session is Up, and that both parties are fully synchronized.
      This switch can be done at any time during a session.</t>

      <t>It is RECOMMENDED that implementations periodically switch to
      the more computationally intensive  authentication type for packets which maintain the
      session in an Up state.  The interval between these switches
      SHOULD be long enough that the system still gains significant
      benefit from using Meticulous Keyed ISAAC Authentication.  See
      <xref target="I-D.ietf-bfd-optimizing-authentication"/>
      for appropriate procedure on switching
      Optimized Authentication Mode.</t>

      <t>When switching to  the more computationally intensive authentication
      mode after ISAAC has been seeded, the Authentication Section's Sequence
      Number field will continue meticulously increasing.  In order to permit
      transition back to ISAAC as the less computationally intensive
      authentication mechanism, it is necessary for ISAAC to continue to
      generate pages appropriate for validating the received sequence
      number.</t>

      <t><xref target="I-D.ietf-bfd-optimizing-authentication"></xref>
      describes the procedures that require the switch to the more
      computationally intensive authentication mode - particularly BFD Poll
      Sequences.</t>

    </section>

    <section anchor="the-yang-model" title="The YANG Model">
      <t>
        This YANG module adds two identities defined in this
        document to the <xref target="RFC8177">IETF Keychain Model</xref>.
        One of them uses the Meticulous Keyed MD5 as the
        more computationally intensive authentication and Meticulous Keyed ISAAC Keyed as the
        less computationally intensive authentication. The other uses
        the Meticulous Keyed SHA-1 as the more computationally intensive authentication and
        Meticulous Keyed ISAAC Keyed as the less computationally
        intensive authentication.
      </t>
      <t>
	<figure>
	  <artwork><![CDATA[
	  <CODE BEGINS> file "ietf-bfd-met-keyed-isaac@YYYY-MM-DD.yang"
          INSERT_TEXT_FROM_FILE(../bin/ietf-bfd-met-keyed-isaac@YYYY-MM-DD.yang,69)
	  <CODE ENDS>
	  ]]></artwork>
	</figure>
      </t>
    </section>

    <section anchor="iana-considerations" title="IANA Considerations">
      <t>
        This documents requests the assignment of two BFD Auth Types, one URI
        and one YANG model.
      </t>
      <section title="BFD Auth Types">
        <t>
          This document requests an update to the registry titled "BFD
          Authentication Types". IANA is requested to assign two new BFD
          AuthType:
	  <ul>
            <li>
              TBD1: Optimized MD5 Meticulous Keyed ISAAC Authentication with a
              suggested value of 7.
	    </li>
	    <li>
	      TBD2: Optimized SHA-1 Meticulous Keyed ISAAC Authentication
	      with a suggested value of 8.
	    </li>
	  </ul>
        </t>
      </section>
      <section anchor="ietf-xml-registry" title="IETF XML Registry">
	<t>
	  This document registers one URIs in the "ns"
	  subregistry of the "IETF XML" registry <xref
	  target="RFC3688"/>. Following the format in <xref
	  target="RFC3688"/>, the following registration is requested:
	</t>
        <t>
	  <figure>
            <artwork>
	      <![CDATA[
URI: urn:ietf:params:xml:ns:yang:ietf-bfd-met-keyed-isaac
Registrant Contact: The IESG
XML: N/A, the requested URI is an XML namespace.
	      ]]>
	    </artwork>
          </figure>
	</t>
      </section>
      <section anchor="yang-module-names" title="The YANG Module Names Registry">
        <t>
	  This document registers one YANG modules in the "YANG Module
	  Names" registry <xref target="RFC6020"/>. Following the
	  format in <xref target="RFC6020"/>, the following
	  registrations are requested:
	</t>
        <t>
	  <figure>
	    <artwork>
	      <![CDATA[
name:         ietf-bfd-met-keyed-isaac
namespace:    urn:ietf:params:xml:ns:yang:ietf-bfd-met-keyed-isaac
prefix:       bfd-mki
reference:    RFC XXXX
	      ]]>
	    </artwork>
          </figure>
	</t>
      </section>
    </section>

    <section anchor="Security" title="Security Considerations">
      <section title="Protocol Security Considerations">
        <t>All security considerations of <xref target="RFC5880"/> and
	<xref target="I-D.ietf-bfd-optimizing-authentication"/> apply to this
	document.</t>

	<t>The security of this proposal depends strongly on the length
	of the Secret Key, and on its entropy.  It is RECOMMENDED
	that the key be 16 octets in length or more.</t>

	<t>The dependency on the Secret Key for security is mitigated
	through the use of two 32-bit numbers: the Your Discriminator field from
	the BFD protocol, and the ISAAC Seed.  Both numbers are procedurally
	required to be random.  These numbers serve as a nonce that inhibits
	attackers from performing an off-line brute-force dictionary attack to
	discover the key.
	</t>

	<t>The security of this proposal depends strongly on ISAAC.
	Research shows that there are few other
	CSRNGs which are as simple and as fast as ISAAC.  For example,
	many other generators are based on AES, which may perform worse than
	ISAAC on resource constrained systems without hardware acceleration.</t>

	<section title="Spoofing">
	  <t>Meticulously Keyed ISAAC authentication protects vs. the spoofing
	  of BFD Up packets and keeping the BFD session Up when it would
	  otherwise be reset.</t>

	  <t>In the event that Meticulously Keyed ISAAC, which is operating as
	  the less computationally intensive authentication mechanism for
	  Optimized BFD, is subverted, the periodic more computationally
	  reauthentication mechanism will limit the time that the session is
	  kept inappropriately in the Up state.
	  (<xref target="I-D.ietf-bfd-optimizing-authentication" section="5"/>)
	  </t>

	  <t>The Meticulous Keyed ISAAC Authentication method allows the
	  BFD end-points to detect a malicious packet via a number of
	  different methods.  Packets which are malformed are discarded.
	  Packets which do not pass the <xref target="RFC5880"
	  sectionFormat="parens" section="6.2">BFD state machine</xref>
	  checks are discarded.  Packets which do not have the correct
	  Sequence Number, Seed and Auth Key are discarded.  These
	  discarded packets have no effect on the BFD state machine.</t>

	  <t>The correlation between the Sequence Number and the Auth
	  Key ensures that each Sequence Number has a corresponding Auth
	  Key associated with it.  The structure and design of the ISAAC
	  CSPRNG ensures that each Auth Key is unique and is
	  unguessable.</t>

	  <t>Performing an attack on this authentication method would require all of the following to be true:</t>

	  <list>
	    <t>The attacker is on-path, and can perform an active attack.</t>

	    <t>The attacker has the contents of one or more packets.</t>

	    <t>The attacker has deduced the Secret Key used for ISAAC,
	    and is able to correlate the Sequence Number to the current
	    ISAAC state.</t>
	  </list>

	  <t>These conditions are unlikely to all be true.
	  If the Secret Key is long and
	  complex, the search space to guess the Secret Key is too large to
	  discover via brute-force.  The use of the Seed and Your Discriminator
	  fields when seeding ISAAC adds 64 bits of entropy to each session,
	  which further makes off-line dictionary attacks impractical. </t>

	</section>

	<section title="Re-Use of keys">
	  <t>The cryptographic strength of the Auth-Type methods is significantly
	  different between SHA-1 and ISAAC.  While
	  ISAAC has had cryptanalysis, and has not been shown to be
	  broken, that analysis is limited. The question then is whether
	  or not it is safe to use the same key for both Auth Type
	  methods (SHA1 and ISAAC), or should we require different
	  keys for each method?</t>

	  <t>If we recommend different keys, then it is possible for the
	  two keys to be configured differently on each side of a BFD
	  link.  For example, a correctly configured key could allow to
	  the BFD state machine to advance to Up.  Then when the session
	  switches to using to weaker Auth Type with a different key,
	  that key may not match, and the session would immediately drop.
	  Suggesting instead that the keys be identical means that no
	  such misconfiguration is possible.</t>

	  <t>Implementations are therefore free to use the same key, or
	  different keys.  The use of the same key for for both more and less
	  computationally intensive authentication is acceptable, as ISAAC is
	  keyed not only with the authentication key, but also depends on 32
	  bits of random data, along with 32 bits of a Sequence Number.  The
	  use of this added randomness increases the difficulty of breaking the
	  key.</t>
	</section>
      </section>

      <section anchor="YANG Security" title="YANG Security Considerations">
	<t>
	  This section is modeled after the template described in Section 3.7
	  of <xref target="I-D.ietf-netmod-rfc8407bis"/>.
	</t>
	<t>
	  The "ietf-bfd-met-keyed-isaac" YANG module defines a data model that
	  is designed to be accessed via YANG-based management protocols, such
	  as <xref target="RFC6241">NETCONF</xref> or <xref target="RFC8040">RESTCONF</xref>.
	  These YANG-based management protocols (1) have to use a secure
	  transport layer (e.g., <xref target="RFC4252">SSH</xref>
	  <xref target="RFC8446">TLS</xref>, and <xref target="RFC9000">QUIC</xref>)
	  and (2) have to use mutual authentication.
	</t>

	<t>
	  The Network Configuration Access Control Model
	  <xref target="RFC8341">(NACM)</xref> provides the means to restrict
	  access for particular NETCONF or RESTCONF users to a preconfigured
	  subset of all available NETCONF or RESTCONF protocol operations and
	  content.
	</t>

	<t>
	  The YANG module defines a set of identities. These identities are
	  intended to be reused by other YANG modules. The module by itself
	  does not expose any data nodes that are writable, data nodes that
	  contain read-only state, or RPCs.  As such, there are no additional
	  security issues related to the YANG module that need to be
	  considered.
	</t>
      </section>
    </section>

    <section title="Contributors" anchor="contributors">
      <t>
	The authors of this document want to acknowledge Ankur Saxena
	and Reshad Rahman as contributors to this document.
      </t>
    </section>

    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>
	The authors want to thank Ketan Talaulikar for his reviews and
	suggestions that have improved the document.
      </t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include="reference.RFC.2119.xml"?>
      <?rfc include='reference.RFC.3688.xml'?>
      <?rfc include='reference.RFC.5880.xml'?>
      <?rfc include='reference.RFC.6020.xml'?>
      <?rfc include='reference.RFC.8174.xml'?>
      <?rfc include='reference.RFC.8177.xml'?>
      <?rfc include='reference.I-D.ietf-bfd-optimizing-authentication.xml'?>

      <reference anchor="ISAAC">
	<front>
	  <title>ISAAC</title>
	  <author initials="R. J." surname="Jenkins" fullname="Robert J. Jenkins Jr."/>
	  <date year="1996"/>
	</front>
	<refcontent>http://www.burtleburtle.net/bob/rand/isaac.html</refcontent>
      </reference>
    </references>

    <references title="Informative References">
      <reference anchor="ISAAC+">
	<front>
	  <title>On the pseudo-random generator ISAAC</title>
	  <author initials="J-P." surname="Aumasson" fullname="Jean-Philippe Aumasson"/>
	  <date year="2006"/>
	</front>
	<refcontent>https://eprint.iacr.org/2006/438.pdf</refcontent>
      </reference>
      <?rfc include='reference.RFC.4252.xml'?>
      <?rfc include='reference.RFC.6241.xml'?>
      <?rfc include='reference.RFC.8040.xml'?>
      <?rfc include='reference.RFC.8341.xml'?>
      <?rfc include='reference.RFC.8446.xml'?>
      <?rfc include='reference.RFC.9000.xml'?>
      <?rfc include='reference.I-D.ietf-netmod-rfc8407bis.xml'?>
    </references>
  </back>
</rfc>
