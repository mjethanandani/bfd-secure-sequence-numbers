<?xml version="1.0" encoding="US-ASCII"?>
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="3"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<rfc
    category="exp"
    docName="draft-ietf-bfd-secure-sequence-numbers-latest"
    ipr="trust200902"
    submissionType="IETF"
    consensus="true">

  <front>
    <title abbrev="ISAAC Authentication">Meticulous Keyed ISAAC for
    BFD Optimized Authentication</title>

    <author fullname="Alan DeKok" initials="A" surname="Dekok">
      <organization>InkBridge Networks</organization>

      <address>
        <postal>
          <street>100 Centrepointe Drive #200</street>

          <city>Ottawa</city>

          <region>ON</region>

          <code>K2G 6B1</code>

          <country>Canada</country>
        </postal>

        <phone/>

        <facsimile/>

        <email>alan.dekok@inkbridge.io</email>

        <uri/>
      </address>
    </author>

    <author fullname="Mahesh Jethanandani" initials="M" surname="Jethanandani">
      <organization>Kloud Services</organization>

      <address>
        <postal>
          <street/>

          <city/>

          <region/>

          <code/>

          <country/>
        </postal>

        <phone/>

        <email>mjethanandani@gmail.com</email>

        <uri/>
      </address>
    </author>

    <author fullname="Sonal Agarwal" initials="S" surname="Agarwal">
      <organization>Cisco Systems, Inc</organization>

      <address>
        <postal>
          <street>170 W. Tasman Drive</street>

          <city>San Jose</city>

          <region>CA</region>

          <code>95070</code>

          <country>USA</country>
        </postal>

        <phone/>

        <facsimile/>

        <email>agarwaso@cisco.com</email>

        <uri>www.cisco.com</uri>
      </address>
    </author>

    <author fullname="Ashesh Mishra" initials="A" surname="Mishra">
      <organization>Aalyria Technologies</organization>

      <address>
        <postal>
          <street/>

          <city/>

          <region/>

          <code/>

          <country/>
        </postal>

        <phone/>

        <facsimile/>

        <email>ashesh@aalyria.com</email>

        <uri/>
      </address>
    </author>

    <author fullname="Ankur Saxena" initials="A" surname="Saxena">
      <organization>Ciena Corporation</organization>

      <address>
        <postal>
          <street>3939 North First Street</street>

          <city>San Jose</city>

          <region>CA</region>

          <code>95134</code>

          <country>USA</country>
        </postal>

        <phone/>

        <facsimile/>

        <email>ankurpsaxena@gmail.com</email>

        <uri/>
      </address>
    </author>

    <date/>

    <abstract>
      <t>
	This document describes a new BFD Optimized Authentication Mode,
	Meticulous Keyed ISAAC Authentication.  This mode  can be used to
	authenticate BFD packets with less CPU time cost than using
	MD5 or SHA1, with the tradeoff of decreased security.  This
	mechanism cannot be used to signal state changes, but it can
	be used to maintain a session in the the "Up" state.
      </t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>
	<xref target="RFC5880" sectionFormat="parens"
	section="6.7">BFD</xref> defines a number of authentication
	mechanisms, including Simple Password, and various other
	methods based on MD5 and SHA1 hashes.  The benefit of using
	cryptographic hashes is that they are secure.  The downside to
	cryptographic hashes is that they are expensive and time
	consuming on resource-constrained hardware.
      </t>

      <t>
	When BFD packets are unauthenticated, it is possible for an
	attacker to forge, modify, and/or replay packets on a link.
	These attacks have a number of side effects.  They can cause
	parties to believe that a link is down, or they can cause
	parties to believe that the link is up when it is, in fact,
	down.  The goal of this specification is to use a simple
	method to prevent spoofing of the BFD session being "Up".  We
	therefore define a Optimized Auth Type that allows parties
	to securely signal that they are still in the Up state.
      </t>

      <t>This document proposes the use of an Authentication method
      which provides per-packet authentication using methods similar to that defined in  <xref
	target="RFC5880">BFD</xref> for Meticulous Keyed MD5 and Meticulous Keyed SHA1.  The method defined here has the benefit that it has less impact on
      resource constrained systems than either MD5 or SHA1.  The algorithm chosen is a seeded
      pseudo-random number generator named <xref
      target="ISAAC">ISAAC</xref>.  ISAAC has been subject to
      significant cryptanalysis in the past thirty years, most notably
      <xref target="ISAAC+">ISAAC+</xref>.  The only issue found was
      with initial seeding, and the method proposed here is safe from
      that attack.  ISAAC requires only a few CPU operations per
      generated 32-bit number, can take a large secret key as a seed,
      and it has an extremely long cycle length.  These properties make it
      ideal for use in BFD.</t>
    </section>

    <section title="Requirements Language">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
      "OPTIONAL" in this document are to be interpreted as described
      in <xref target="RFC2119">RFC 2119</xref>.</t>
    </section>

    <section title="Experimental updates to RFC 5880">
      <t>
	This document describes an experimental update to <xref
	target="RFC5880">BFD</xref>. This experiment is intended to
	provide additional insights into what happens when the
	authentication method defined in this document is used.
      </t>

      <t>
	This document is classified as Experimental and is not part of
	the IETF Standards Track. Implementations based on this
	document should not be considered as compliant with <xref
	target="RFC5880">BFD</xref> and should not assume
	interoperability with other implementations that conform to
	the existing document.
      </t>

      <t>
	Some of the state variables in <xref target="RFC5880"
	sectionFormat="parens" section="6.8.1">BFD</xref>, are related
	to the authentication type being used for a particular
	session.  However, the definitions given in <xref
	target="RFC5880">BFD</xref> are specific to Keyed MD5 or SHA1
	Authentication, which limit their utility for new
	authentication types. For the purpose of the experiment, this
	specification updates the definition of some of the state
	variables as given below.
      </t>

      <t>
	These updated definitions are entirely compatible with the
	definitions given in <xref target="RFC5880"
	sectionFormat="parens" section="6.8.1">BFD</xref>, and require
	no changes to existing configurations or
	implementations. Instead, the updated definitions clarify that
	the state variables apply to the current authentication type,
	no matter what it is.
      </t>

      <t>
	We first update the <xref target="RFC5880">RFC5080</xref>
	definitions, and then define a new authentication type which
	uses these updated definitions.
      </t>

      <t>These updated definitions also mean that Authentication
      Sections SHOULD include a Sequence Number field.  Where a
      Sequence Number is not used (as with Simple Password) the
      variables bfd.RcvAuthSeq and bfd.XmitAuthSeq MUST be set to
      zero.  Where an Authentication Section uses a meticulous keyed
      authentication type, it MUST include a Sequence Number
      field.</t>

      <dl newline="true">
	<dt>
	  bfd.AuthType:
	</dt>
	<dd>
	  <t>
	    The current authentication type in use for this session,
	    as defined in <xref target="RFC5880"
	    sectionFormat="parens" section="4.1">BFD</xref>, or zero
	    if no authentication is in use.
	  </t>

	  <t>
	    Packets which indicate a state transition MUST use a
	    stronger authentication method.  When the bfd.SessionState
	    value is Up, packets MAY use a less computationally
	    intensive one, such as Meticulous Keyed ISAAC.
	  </t>
	</dd>

	<dt>
	  bfd.RcvAuthSeq:
	</dt>
	<dd>
	  A 32-bit unsigned integer containing the last sequence
	  number for the current Authentication Section that was
	  received.  The initial value is unimportant.
	</dd>

	<dt>
	  bfd.XmitAuthSeq:
	</dt>
	<dd>
	  A 32-bit unsigned integer containing the next sequence
	  number for the Authentication Section which will be
	  transmitted.  This variable MUST be initialized to a random
	  32-bit value.  This value SHOULD be taken from a
	  cryptographically strong pseudo-random number generator
	  (CSPRNG).
	</dd>

	<dt>
	  bfd.AuthSeqKnown:
	</dt>
	<dd>
	  <t>
	    Set to 1 if the next expected Authentication Section has a
	    sequence number which is known, or 0 if it is not known.
	    This variable MUST be initialized to zero.
	  </t>

	  <t>
	    This variable MUST be set to zero after no packets have
	    been received on this session for at least twice the
	    Detection Time.  This ensures that the sequence number can
	    be resynchronized if the remote system restarts.
	  </t>
	</dd>
      </dl>
    </section>

    <section title="Architecture of the Auth Type Method">
      <t>
	When BFD uses authentication, methods using MD5 or SHA1 are
	CPU intensive, and can negatively impact systems with limited
	computational power.
      </t>

      <t>
	However, once the session transitions into the Up state, there
	may not be a need to authenticate every packet. However,
	removing authentication entirely poses issues where an
	attacker could spoof packets, causing a session to erroneously
	remain in the Up state.</t>

	<t>
	  Instead, an optimized authentication mechanism
	as described in <xref
	target="I-D.ietf-bfd-optimizing-authentication">Optimizing BFD
	Authentication</xref>, permits BFD to use a relaxed
	authentication, that satisfies the ability to provde a less
	expensive authentication, but strong enough that periodic
	reauthentication is not strictly required to prevent an
	on-path attack.
      </t>

      <t>We use ISAAC here as a way to generate an infinite stream of
      pseudo-random numbers, referred to here as "Auth-Key"s.  With
      Meticulous Keyed ISAAC Authentication, these Auth Keys are used
      as a signal that the sending party is authentic.  That is, only
      the sending party can generate the correct Auth-Keys.  Therefore
      if the receiving party sees a correct Auth-Key, then only the
      sending party could have generated it.  The sender is therefore
      authentic, even if the packet contents have potentially been
      modified in transit.</t>

      <t>Note that with this Auth Type method, the full packet
      contents are not signed or authenticated.  Therefore, Meticulous
      Keyed ISAAC Authentication MUST NOT be used to signal BFD state
      changes. For BFD state changes, and a more optimized way to
      authenticate packets, please refer to <xref
      target="I-D.ietf-bfd-optimizing-authentication">BFD
      Authentication</xref>. Instead, the packets containing
      Meticulous Keyed ISAAC Authentication are only a signal that the
      sending party is still alive, and that the sending party is
      authentic.  That is, this Auth Type method MUST only be used
      when bfd.SessionState=Up, and the State (Sta) field equals 3
      (Up).</t>
    </section>

    <section title="Meticulous Keyed ISAAC Authentication Format" anchor="meticulous_keyed_isaac">

      <t>If the Authentication Present (A) bit is set in the header,
      and the State (Sta) field equals 3 (Up), and the Authentication
      Type field contains Optimized MD5 Meticulous Keyed ISAAC Authentication (TBD1); or
	  Optimized SHA-1 Meticulous Keyed ISAAC Authentication (TBD2), the Authentication Section has the
      following format:</t>

      <figure>
        <artwork><![CDATA[
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   Auth Type   |   Auth Len    |  Auth Key ID  |   Opt. Mode   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Sequence Number                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             Seed                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                            Auth-Key                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ]]></artwork>
      </figure>

      <dl newline="true">
	<dt>
	    Auth Type:
	</dt>
	<dd>
	  The current Auth Type.  It MUST provide for meticulous
	  keying.  That is, an authentication type where each packet
	  is authenticated, and also where the Sequence Number field
	  is incremented by one (1) for every packet which is sent.
	</dd>

	<dt>
	  Auth Len:
	</dt>
	<dd>
	    The length of the Authentication Section, in bytes.  For
	    Meticulous Keyed ISAAC Authentication, the length is 16.
	</dd>

	<dt>
	  Auth Key ID:
	</dt>
	<dd>
          The authentication key ID in use for this packet.  This
          allows multiple secret keys to be active simultaneously.
	</dd>

	<dt>
	  Opt Mode:
	</dt>
	<dd>
	  The Optimized Authentication Mode, as defined in <xref
	  target="I-D.ietf-bfd-optimizing-authentication"/>.  allows
	  for systems to switch to a less computationally intensive
	  authentication method, without changing the main
	  bdf.AuthType.
	</dd>

	<dt>
	  Sequence Number:
	</dt>
	<dd>
          The sequence number for this packet.  For Meticulous Keyed
          ISAAC Authentication, this value is incremented once for
          each successive packet transmitted for a session.  This
          provides protection against replay attacks.
	</dd>

	<dt>
	  Seed:
	</dt>
	<dd>
	  A 32-bit (4 octet) seed which is used in conjunction with
	  the shared key in order to configure and initialize the
	  ISAAC pseudo-random-number-generator (PRNG).  It is used to
	  identify and secure different "streams" of random numbers
	  which are generated by ISAAC.
	</dd>

	<dt>
	  Auth-Key:
	</dt>
	<dd>
	  <t>
	    This field carries the 32-bit (4 octet) ISAAC output which
	    is associated with the Sequence Number.  The ISAAC PRNG
	    MUST be configured and initialized as given in <xref
	    target="seeding-isaac"/>, below.
	  </t>
	  <t>
	    Note that the Auth-Key here does not include any summary
	    or hash of the packet.  The packet itself is completely
	    unauthenticated.
	  </t>
	</dd>
      </dl>
      <t>When the receiving party receives a BFD packet with an
      expected sequence number and the correct corresponding ISAAC
      output in the Auth Key field, it knows that only the authentic
      sending party could have sent that message.  The sending party is
      therefore "Up", as it is the only one who could have sent the
      message.</t>
    </section>

    <section title="Meticulous Keyed ISAAC Authentication">
      <t>In this mode of optimized authentication, one or more secret
      keys (with corresponding key IDs) are configured in each system.
      One of the keys is used to seed the ISAAC PRNG.  The output of
      ISAAC is used to signal that the sender is authentic.  To help
      avoid replay attacks, a sequence number is also carried in each
      packet.  For Meticulous Keyed ISAAC Authentication, the sequence number MUST be
      incremented by one on every packet.</t>

      <t>The receiving system accepts the packet if the key ID matches
      one of the configured Keys, and the Auth-Key derived from the
      selected Key, Seed, and Sequence Number matches the Auth-Key
      carried in the packet, and the sequence number is strictly
      greater than the last sequence number received (modulo wrap at
      2^32).  If any of these criteria do not match, the packet is
      considered to be inauthentic, and is discarded.</t>

      <t>
	Transmission Using Meticulous Keyed ISAAC Authentication
      </t>
      <list empty="true">
	<t>
	  The Auth Type field MUST be set to one of two values;
	  Optimized MD5 Meticulous Keyed ISAAC Authentication (TBD1); or
	  Optimized SHA-1 Meticulous Keyed ISAAC Authentication (TBD2).
	</t>
	<t>
          The Auth Len field MUST be set to 16.
	</t>
	<t>
          The Auth Key ID field
	  MUST be set to the ID of the current authentication key.
	  The Sequence Number field MUST be set to bfd.XmitAuthSeq.
	</t>

	<t>
	  The Seed field MUST be set to the value of the current seed
	  used for this session.
	</t>

	<t>
	  The Auth-Key field MUST be set to the output of ISAAC, which
	  depends on the secret Key, the current Seed, and the
	  Sequence Number.
	</t>

	<t>
          The Optimized Authentication Mode field MUST be 2, the "less
          computationally intensive authentication type". See <xref
          target="I-D.ietf-bfd-optimizing-authentication"
          section="3.0"/>.
	</t>

	<t>
	  For Meticulous Keyed ISAAC Authentication, bfd.XmitAuthSeq MUST be
	  incremented by one on each packet, in a circular fashion (when
	  treated as an unsigned 32-bit value).  The bfd.XmitAuthSeq
	  MUST NOT be incremented by more than one for a packet.
	</t>
      </list>

      <t>
	Receipt using Meticulous Keyed ISAAC Authentication
      </t>
      <list empty="true">
	<t>
	  If the received BFD Control packet does not contain an
	  Authentication Section, or the Auth Type is not correct (either Optimized MD5 Meticulous Keyed ISAAC Authentication (TBD1) or
	  Optimized SHA-1 Meticulous Keyed ISAAC Authentication (TBD2)), then the received packet MUST be discarded.
	</t>

	<t>
	  If the Auth Key ID field does not match the ID of a
	  configured authentication key, the received packet MUST be
	  discarded.
	</t>

	<t>
	  If the Optimized Authentication Mode is not 2, <xref
	  target="I-D.ietf-bfd-optimizing-authentication"
	  section="3.0"/>, the received packet MUST be discarded.
	</t>

	<t>
	  If the Auth Len field is not equal to 16, the packet MUST be
	  discarded.
	</t>

	<t>
	  If bfd.AuthSeqKnown is 1, examine the Sequence Number field.
	  For Meticulous keyed ISAAC, if the sequence number lies
	  outside of the range of bfd.RcvAuthSeq+1 to
	  bfd.RcvAuthSeq+(3*Detect Mult) inclusive (when treated as an
	  unsigned 32-bit circular number space) the received packet
	  MUST be discarded.
	</t>

	<t>
	  If bfd.MetKeyIsaacRcvKeyKnown is "true" and the Seed field
	  does not match the current Seed value,
	  bfd.MetKeyIsaacRcvAuthSeed, the packet MUST be discarded.
	</t>

	<t>
	  Calculate the current expected output of ISAAC, which
	  depends on the secret Key, the current Seed, and the
	  Sequence Number.  If the value does not matches the Auth-Key
	  field, then the packet MUST be discarded.
	</t>

	<t>
	  If bfd.MetKeyIsaacRcvKeyKnown is "false", the ISAAC related
	  variables are initialized as per <xref
	  target="receiver-variable-initialization"/> using the
	  contents of the packet.
	</t>

	<t>
	  Note that in some cases, calculating the expected output of
	  ISAAC will result in the creation of a new "page" of 256
	  numbers.  This process will be irreversible, and will
	  destroy the current "page".  As a result, if the generation
	  of a new output will create a new "page", the receiving
	  party MUST save a copy of the entire ISAAC state before
	  proceeding with this calculation.  If the outputs match,
	  then the saved copy can be discarded, and the new ISAAC
	  state is used.  If the outputs do not match, then the saved
	  copy MUST be restored, and the modified copy discarded, or
	  cached for later use.
	</t>
      </list>
    </section>

    <section title="New State variables for Meticulous Keyed ISAAC Authentications">
      <t>
	This document defines new state variables for use with
	Meticulous Keyed ISAAC Authentication.
      </t>

      <dl newline="true">
	<dt>
	  bfd.MetKeyIsaacRcvKeyKnown:
	</dt>
	<dd>
	  A boolean value which indicates whether or not the system
	  knows the receive key for the Meticulous Keyed ISAAC
	  Authentication.  The initial value is "false".  This value
	  is changed to "true" when a party verifies that the other
	  party has started to use the Meticulous Keyed ISAAC
	  Authentication, with an authenticated Auth Key.
	</dd>

	<dt>
	  bfd.MetKeyIsaacRcvAuthBase:
	</dt>
	<dd>
	  A 32-bit unsigned integer containing a copy of the
	  bfd.RcvAuthSeq number which is associated with the current
	  ISAAC "page" for authenticating received packets.
	</dd>

	<dt>
	  bfd.MetKeyIsaacRcvAuthIndex:
	</dt>
	<dd>
	  An 8-bit number used to index within a particular "page" of
	  pseudo-random numbers.
	</dd>

	<dt>
	  bfd.MetKeyIsaacRcvAuthSeed:
	</dt>
	<dd>
	  A 32-bit unsigned integer containing a copy of the Seed
	  associated with received packets.
	</dd>

	<dt>
	  bfd.MetKeyIsaacRcvAuthData:
	</dt>
	<dd>
	  A data structure which contains the ISAAC data for the
	  received Auth Type method.
	</dd>

	<dt>
	  bfd.MetKeyIsaacXmitKeyKnown:
	</dt>
	<dd>
	  A boolean value which indicates whether or not the system
	  knows the xmit key for Meticulous Keyed ISAAC Authentication.
	  The initial value is "false".  This value is
	  changed to "true" when a party starts to transmit using
	  Meticulous Keyed ISAAC Authentication.
	</dd>

	<dt>
	  bfd.MetKeyIsaacXmitAuthBase:
	</dt>
	<dd>
	  A 32-bit unsigned integer containing a copy of the
	  bfd.XmitAuthSeq number which is associated with the current
	  ISAAC "page" for authenticating sent packets.
	</dd>

	<dt>
	  bfd.MetKeyIsaacXmitAuthIndex:
	</dt>
	<dd>
	  An 8-bit number used to index within a particular "page" of
	  pseudo-random numbers.
	</dd>

	<dt>
	  bfd.MetKeyIsaacXmitAuthSeed:
	</dt>
	<dd>
	  A 32-bit unsigned integer containing a copy of the Seed
	  associated with sent packets.
	</dd>

	<dt>
	  bfd.MetKeyIsaacXmitAuthData:
	</dt>
	<dd>
	  A data structure which contains the ISAAC data for the
	  sending Auth Type method.
	</dd>
      </dl>
    </section>

    <section title="Secret Key">
      <t>The security of the Meticulous Keyed ISAAC Auth Type depends on the Secret Key.
      The Secret Key is mixed with a per-session Seed as discussed
      below.  The result is used to initialize a stream of
      pseudo-random numbers using the ISAAC random number
      generator.</t>

      <t>A particular Secret Key is identified via the Auth Key ID
      field.  This Auth Key ID is either placed in the packet by the
      sender, or verified by the receiver.  Meticulous Keyed ISAAC
      Authentication permits systems to have multiple Secret
      Keys configured, but we do not discuss how those keys are
      managed or used.  We do, however, require that a session MUST
      NOT change the Auth Key ID for Meticulous Keyed ISAAC Authentication, during a
      session.  There is no defined way to re-sync or re-initialize an
      ongoing session with a different Auth Key ID and correspondingly
      different Secret Key.</t>

      <t>
	If this Auth Type method was defined as being initialized
	without a per-session Seed, then an attacker could pre-compute
	the ISAAC states for many keys, and perform an off-line
	dictionary attack.  The use of the Seed makes these attacks
	unfeasable.
      </t>

      <t>For interoperability, the management interface by which the
      key is configured MUST accept ASCII strings, and SHOULD also
      allow for the configuration of any arbitrary binary string in
      hexadecimal form.  Other configuration methods MAY be
      supported.</t>

      <t>The Secret Key MUST be at least eight (8) octets in length,
      and SHOULD NOT be more than 128 octets in length.</t>

      <t>There are no known issues with using the same secret Key for
      multiple Auth Type methods.  However, it is RECOMMENDED that
      administrators use different Secret Keys for each Auth Type.</t>
    </section>

    <section title="Transition to using ISAAC">
      <t>Once a BFD session transitions to the Up state, the packets MAY
      use Meticulous Keyed ISAAC Authentication. A system receiving
      such a packet will initialize the ISAAC PRNG state using the
      Seed from the first packet which is seen to use Meticulous Keyed ISAAC Authentication. A system originating a packet using Meticulous Keyed ISAAC Authentication will
      generate a Seed, and place it into the packet which is then
      sent.  Further discussion of initialization is below in
      <xref target="sender-variable-initialization"/> and
      <xref target="receiver-variable-initialization"/>.</t>

      <t>The transition to the Up state is the only time when the
      ISAAC random number generator is initialized.  In contrast, a
      temporary transition away from using Meticulous Keyed ISAAC
      Authentication (<xref target="transition-away"/>) and back, does
      not cause ISAAC to be re-keyed.</t>

      <t>There is no negotiation as to when authentication switches
      from the original type, to using Meticulous Keyed ISAAC.  The
      sender simply begins sending packets with a relevant Auth-Type,
      and with the Optimized Authentication Mode field set to 1.  When
      the sender switches to using using Meticulous Keyed ISAAC
      Authentication, it sets the Optimized Authentication Mode field
      to 2, and starts performing the ISAAC calculations as described
      here.</t>

      <t>Similarly, a receiving system switches to using this method
      when it sees that it has received a packet contains Optimized
      Authentication Mode field set to 2 when
      bfd.MetKeyIsaacRcvKeyKnown variable is "false".  The receiving
      system then initializes its variables, and authenticates the
      received packet, by comparing the Auth Key in the packet with
      the key it generated itself.</t>

      <t>However, the operation of those variables MUST now satisfy
      the requirements of the new Optimized Authentication Mode.</t>

      <t>That is, when changing Optimized Authentication mode in a session, the current
      value of the bfd.RcvAuthSeq and bfd.XmitAuthSeq variables is
      used as the initial value(s) for the new mode.</t>

      <t>When there is a transition to using ISAAC the first time, the initial
      ISAAC state has to be seeded.  The next section describes this seeding
      process.</t>

    </section>

    <section title="Seeding ISAAC" anchor="seeding-isaac">
      <t>The Seed field is used to identify and secure
      different "streams" of random numbers which are generated by
      ISAAC.  Each session uses a different Seed, which is used along
      with the "Your Discriminator" field, and the Secret Key, to
      initialize ISAAC.</t>

      <t>The value of the Seed field MUST be derived from a CSPRNG
      source.  Exactly how this can be done is outside of the scope of
      this document.</t>

      <t>A new Seed value MUST be created every time a BFD session
      transitions into the "Up" state.  In order to prevent continuous
      rekeying, once the session is in the "Up" state, the Seed for a
      session MUST NOT be changed until another state transition
      occurs.</t>

      <t>The ISAAC PRNG is initialized by setting all internal
      variables and data structures to zero (0).  The PRNG is then
      seeded by using the the following structure:</t>

      <figure>
          <artwork><![CDATA[
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             Seed                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       Your Discriminator                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          Secret Key ...            |  Counter |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            ]]></artwork>
        </figure>

    <t>Where the "Your Discriminator" field is taken from the BFD
    packet defined in <xref target="RFC5880">RFC5880 Section
    4.1</xref>.  This field is taken from the respective values used
    by a sending system.  For receiving systems, the field are taken
    from the received packet.  The length of the Secret Key MUST be
    1016 octets or less.  The Counter field is used to ensure the the
    initial seeding of ISAAC avoids the seeding issues discussed in
    <xref target="ISAAC+">ISAAC+</xref>.</t>

    <t>
      The ISAAC "page" is initialized by filling it with repeated
      copies of the above structure.  For each complete copy of the
      structure, the Counter field is incremented, starting from zero
      (0).  This process may finish with a partial copy of the above
      structure, in which case only a prefix of the structure is
      copied.
    </t>

    <t>Once the ISAAC "page" is initialized, the data is processed
    throught the "randinit()" function of ISAAC.  Pseudo-random
    numbers are then produced 32 bits at a time by calling the
    "isaac()" function.</t>

    <t>For the sender, this calculation can be done outside of the BFD
    "fast path" as soon as the "Your Discriminator" value is known.
    For the receiver, this calculation can only be done when the Seed
    is received from the sender, and therefore needs to be done in the
    BFD "fast path".</t>

    <t>
      The following figure gives Seed and Your-Discriminator as 32-bit
      hex values, and the Secret Key as an eleven-character string.
      The subsequent figure shows the first eight Sequence numbers and
      corresponding Auth Key values which were generated using the
      above initial values.
    </t>

      <figure>
          <artwork><![CDATA[
Seed	0x0bfd5eed
Y-Disc	0x4002d15c
Key	RFC5880June
            ]]></artwork>
        </figure>


      <figure>
          <artwork><![CDATA[
Sequence Auth Key
0        4e13bbfc
1        8f80176a
2        56ea9eeb
3        6950dc88
4        46e6ada6
5        5a823dc9
6        221d032d
7        d1beedf3
            ]]></artwork>
        </figure>

    <t>Note that this construct requires that the "Your Discriminator"
    field not change during a session.  However, it does allow the "My
    Discriminator" field to change as permitted by <xref
    target="RFC5880">RFC5880 Section 6.3</xref></t>

     <t>This construct provides for 64 bits of entropy, of which 32
     bits is controlled by each party in a BFD session.  For security,
     each implemention SHOULD randomize their iscrimator fields at
     the start of a session, as discussed in <xref
     target="RFC5880">RFC5880 Section 10</xref>.</t>

     <t>
       There is no way to signal or negotiate Seed changes.  The
       receiving party MUST remember the current Seed value.  Tthe Seed value MUST NOT
       change unless sending party has signalled a BFD state change
       with a packet that is authenticated using a stronger
       authentication method.  When a system receives a BFD packet containing Meticulous Keyed ISAAC
      Authentication, it MUST check that the received Seed contains the expected value, and if not, it MUST discard the packet as inauthentic.
     </t>

     <section title="Sender Variable Initialization"
      anchor="sender-variable-initialization">
       <t>A system which sends packets initializes ISAAC as described
       above.  The ISAAC related variables are initialized as
       follows:</t>

       <dl newline="true">
	 <dt>
	   bfd.MetKeyIsaacXmitKeyKnown:
	 </dt>
	 <dd>
	   This variable transitions from "false" to "true" when the
	   sender decides to start using ISAAC.  The sender also
	   initializes the other variables at the same time.
	 </dd>

	 <dt>
	   bfd.MetKeyIsaacXmitAuthBase:
	 </dt>
	 <dd>
	   The sender copies the bfd.XmitAuthSeq number from the
	   current packet to be sent into this variable.
	 </dd>

	 <dt>
	   bfd.MetKeyIsaacXmitAuthIndex:
	 </dt>
	 <dd>
	   The sender sets this variable to zero.
	 </dd>

	 <dt>
	   bfd.MetKeyIsaacXmitAuthSeed:
	 </dt>
	 <dd>
	   The sender copies the current Seed value into this
	   variable.  This variable is then copied into the "Seed"
	   field of each Auth Type packet.
	 </dd>

	 <dt>
	   bfd.MetKeyIsaacXmitAuthData:
	 </dt>
	 <dd>
	   The ISAAC state for sending is encapsulated in this
	   variable.
	 </dd>
       </dl>
     </section>

     <section title="Receiver Variable Initialization"
      anchor="receiver-variable-initialization">
       <t>
	 When a system receives packets with Meticulous Keyed
	 ISAAC Authentication and is able to authenticate such a
	 packet the first time, the ISAAC related variables are
	 initialized as follows:
       </t>
       <dl newline="true">
	 <dt>
	   bfd.MetKeyIsaacRcvKeyKnown:
	 </dt>
	 <dd>
	   This variable transitions from "false" to "true" when the
	   receiver sees that the sender has started using Meticulous
	   Keyed ISAAC Authentication.  The receiver also initializes
	   the other variables at the same time.
	 </dd>

	 <dt>
	   bfd.MetKeyIsaacRcvAuthBase:
	 </dt>
	 <dd>
	   The bfd.RcvAuthSeq number from the current packet
	   is copied into this variable.
	 </dd>

	 <dt>
	   bfd.MetKeyIsaacRcvAuthIndex:
	 </dt>
	 <dd>
	   The receiver sets this value to zero
	 </dd>

	 <dt>
	   bfd.MetKeyIsaacRcvAuthSeed:
	 </dt>
	 <dd>
	   The receiver copies the Seed value from the received packet
	   into this variable.  Note that this copy only occurs when the
	   bfd.MetKeyIsaacXmitKeyKnown variable transitions from "false"
	   to true."
	 </dd>

	 <dt>
	   bfd.MetKeyIsaacRcvAuthData:
	 </dt>
	 <dd>
	   The ISAAC state for receiving is encapsulated in this
	   variable.
	 </dd>
       </dl>

       <t>
	 As there may be packet loss, the receiver has to take special
	 care to initialize the bfd.MetKeyIsaacRcvAuthBase variable.
	 If there has been no packet loss, the
	 bfd.MetKeyIsaacRcvAuthBase is taken directly from the
	 bfd.RcvAuthSeq variable, and the bfd.MetKeyIsaacRcvAuthIndex
	 is set to zero.
       </t>

       <t>
	 If, however, the packet's Sequence Number differs from the
	 expected value, then the difference "N" indicates how many
	 packets were lost.  The receiver then has to search through
	 the first "N" Auth Keys derived from its calculated ISAAC
	 state in order to find one which matches.  If no key matches
	 the Auth Key in the packets, the packet is deemed to be
	 inauthentic, and is discarded.
       </t>

      <t>If a calculated key at index "I" does match the Auth Key in
      the packet, then the bfd.MetKeyIsaacRcvAuthIndex field is
      initialized to this value.  The bfd.MetKeyIsaacRcvAuthBase field
      is then initialized to contain the value of bfd.RcvAuthSeq,
      minus the value of bfd.MetKeyIsaacRcvAuthIndex.  This process
      allows the pseudo-random stream to be re-synchronized in the
      event of lost packets.</t>

      <t>That is, the value for bfd.MetKeyIsaacRcvAuthBase is the
      Sequence Number for first Auth Key used in this session.  This
      value may be from a lost packet, but can never the less be
      calculated by the receiver from a later packet.</t>

      <t>This document does not make provisions for dealing with the
      case of losing more than 256 packets.  Implementors should limit
      the value of "Detect Multi" to a small number in order to keep
      the number of lost packets within an acceptable limit.</t>

     </section>

    </section>

    <section title="Operation">
      <t>Once the variables have been initialized, ISAAC will be able
      to produce 256 random numbers to use as Auth Keys, at near-zero
      cost.  The "AuthIndex" field is incremented by one for every new
      Auth Key generated.  Each new value of the Sequence Number field
      (sent or received) is then calculated by adding the relevant
      "AuthBase" and "AuthIndex" fields.</t>

      <t>When all 256 numbers are consumed the "AuthIndex" field will
      wrap to zero.  The ISAAC mixing function is then run, which then
      results in another set of 256 random numbers.  The "AuthBase"
      variable is then incremented by 256, to indicate that 256 Auth
      Keys have been consumed.  This process then continues until a
      BFD state change.</t>

      <t>ISAAC can be thought of here as producing an infinite stream
      of numbers, based on a secret key, where the numbers are
      produced in "pages" of 256 32-bit values.  This property of
      ISAAC allows for essentially zero-cost "seeking" within a page.
      The expensive operation of mixing is performed only once per 256
      packets, which means that most BFD packet exchanges can be fast
      and efficient.</t>

      <t>The receiving party can then look at the Sequence Number to
      determine which particular PRNG value is being used in the
      packet.  By subtracting the bfd.MetKeyIsaacAuthBase from the
      Sequence Number (with possible wrapping), an expected "Index" can be
      derived, and a corresponding Auth Key found.  This process thus permits
      the two parties to synchronize if/when a packet or packets are lost.</t>

      <t>Incrementing the Sequence Number for every packet also
      prevents the re-use of any individual pseudo-random number which
      was derived from ISAAC.</t>

      <t>The Sequence Number can increment without bounds, though it
      can wrap once it reaches the limit of the 32-bit counter field.
      ISAAC has a cycle length of 2^8287, so there is no issue with
      using more than 2^32 values from it.</t>

      <t>The result of the above operation is an infinite series of
      numbers which are unguessable, and which can be used to
      authenticate the sending party.</t>

      <t>Each system sending BFD packets chooses its own seed, and
      generates its own sequence of pseudo-random numbers using ISAAC,
      and place those values into the Auth Key field. Each system
      receiving BFD packets runs a separate pseudo-random number
      generator, and verifies that the received packets contain the
      expected Auth Key.</t>

      <section title="Page Flipping">
	<t>Once all 256 Auth Keys from the current page have been used,
	the "next" page is calculated by calling the isaac() function.
	This function processes the current "page" to create the "next"
	page, and is inherently destructive.  In order to prevent
	issues, care should be taken to perform this process
	correctly.</t>

	<t>It is RECOMMENDED that implementations keep both a "current"
	page, and a "next" page associated with the ISAAC state.  The
	"next" can be calculated by making a copy of the "current" page,
	and then calling the isaac() function.</t>

	<t>The system needs to maintain the "current" page at all
	times when Meticulous Keyed ISAAC Authentication is used.  The
	"next" page does not need to be maintained at all times, and
	can be calculated on demand.  However, in order to avoid
	impacting the fast path, the "next" page should be calculated in
	the background in an asynchronous manner.</t>

	<t>This process has a number of benefits. First, At 60 packets
	per second, the system has approximately four (4) seconds of
	time to calculate the "next" page.  If the calculation is done
	quickly, the "next" page is available to the fast path before
	it is needed.</t>

	<t>Second, having the "next" page available early means that
	an attacker cannot spoof BFD packets, and force the received
	to spend significant resources calculating a "next" page on
	the BFD "fast path".  Instead, the receiver can simply check
	the contents of the "next" page at near-zero cost, and discard
	the spoofed packet.</t>

	<t>When the receiver determines that it needs to move to the
	"next" page, it can simply swap the "current" and "next" pages
	(updating the BFD variables as appropriate), and then begin
	an asynchronous calculation of the "next" page.  Such
	asynchronous calculations are preferable to calculating the
	next page in the BFD fast path.</t>
      </section>

    </section>

    <section title="Transition away from using ISAAC"
	     anchor="transition-away">
      <t>There are two ways to transition away from using ISAAC.  One
      way is via state changes: the link either goes down due to an
      fault, or one party signals a state change via a packet signed
      with a strong authentication.  The second situation is where one
      party wishes to temporarily stronger signal that it is still Up,
      by setting the Optimized Authentication Mode field away from
      value "2" (Meticulous Keyed ISAAC) to value "1" (the strong
      authentication type).</t>

      <t>The switch to the strong authentication type also provides
      for full packet integrity checks, which may be desirable.  This
      switch can be done at any time during a session</t>

      <t>It is RECOMMENDED that implementations periodically switch to
      the strong authentication type for packets which maintain the
      session in an Up state.  The interval between these switches
      SHOULD be long enough that the system still gains significant
      benefit from using Meticulous Keyed ISAAC Authentication.  That
      is, multiple ISAAC pages SHOULD be used in between any switch to
      the strong authentication type.  See <xref
      target="I-D.ietf-bfd-optimizing-authentication">BFD
      Authentication</xref> for appropriate procedure on switching
      Optimized Authentication Mode.</t>

      <t>The nature of Meticulous Keyed ISAAC Authentication means that
      there is no issue with this switch, so long as it is for a small
      number of packets.  From the point of view of the Meticulous
      Keyed ISAAC state machine, this switch can be handled similarly
      to a lost packet.  The state machine simply notices that instead
      of Sequence Number value being one more than the last value used
      for ISAAC, it is larger by two.  The ISAAC state machine then
      calculates the index into the current "page", and uses the found
      number to validate (or send) the Auth Key.</t>

      <t>That is, the switch away from, back to Meticulous Keyed ISAAC
      Authentication MUST NOT cause the Meticulous Keyed ISAAC
      Authentication mode to be re-seeded.  ISAAC is only re-seeded
      when the session transitions to the Up state, and the session
      remains in the Up state during this process.  As a result, no
      re-seeding is performed.</t>

      <t>It is RECOMMENDED that the session use the strong
      authentication type only for one packet, before moving back to
      using Meticulous Keyed ISAAC Authentication.  There are few
      benefits to continuing the strong authentication type for
      extended periods of time.</t>

      <t>If the non-ISAAC Auth Type instead runs for extended periods
      of time, then the ISAAC process must continue "in the
      background" in order to maintain synchronization.  This process
      is needed because this method does not provide for a way to
      reinitialize the ISAAC method with new Seed value.</t>
    </section>

    <section anchor="IANA" title="IANA Considerations">
      <t>
	For IANA Consideration, please refer to the IANA
	Considerations section of <xref
	target="I-D.ietf-bfd-optimizing-authentication">Optimizing BFD
	Authentication</xref>.
      </t>

      <t>Note to RFC Editor: this section may be removed on
      publication as an RFC.</t>
    </section>

    <section anchor="Security" title="Security Considerations">
      <t>The security of this proposal depends strongly on the length
      of the Secret Key, and on its entropy.  It is RECOMMENDED
      that the key be 16 octets in length or more.</t>

      <t>The dependency on the Secret Key for security is mitigated
      through the use of two 32-bit random numbers, with one generated
      by each party to the BFD session.  An attacker cannot simply
      perform an off-line brute-force dictionary attack to discover
      the key.  Instead, any analysis has to include the particular 64
      bits of entropy used for a particular session.  As a result,
      dictionary attacks are more difficult than they would be if the
      PRNG generator depended on nothing more than the Secret Key.</t>

      <t>The security of this proposal depends strongly on ISAAC.
      This generator has been analyzed for almost three decades, and
      has not been broken.  Research shows that there are few other
      CSRNGs which are as simple and as fast as ISAAC.  For example,
      many other generators are based on AES, which is infeasibe for
      resource constrained systems.</t>

      <t>In a keyed algorithm, the key is shared between the two
      systems. Distribution of this key to all the systems at the same
      time can be quite a cumbersome task. BFD sessions running a fast
      rate may require these keys to be refreshed often, which poses
      a further challenge. Therefore, it is difficult to change the
      keys during the operation of a BFD session without affecting the
      stability of the BFD session. Therefore, it is recommended to
      administratively disable the BFD session before changing the
      keys.</t>

      <t>That is, while the Auth Key ID field provides for the use of
      multiple keys simultaneously, there is no way for each party to
      signal which Key IDs are supported.</t>

      <t>The Auth Type method defined here allows the BFD end-points
      to detect a malicious packet, as the calculated hash value will
      not match the value found in the packet. The behavior of the
      session, when such a packet is detected, is based on the
      implementation. A flood of such malicious packets may cause a
      BFD session to be operationally down.</t>

      <section title="Spoofing">
	<t>When Meticulous Keyed ISAAC Authentication is used, it is
	possible for an attacker who can see the packets to observe a
	particular Auth Key value, and then copy it to a different
	packet as a on-path attacker attack.  However, the usefulness
	of such an attack is limited by the correlation between the
	Sequence Number and the Auth Key.  That is, each Sequence
	Number has a unique Auth Key associated with it.</t>

	<t>The <xref target="RFC5880">BFD state machine</xref> checks
	ensure that only packets with a correct Sequence Number are
	accepted.  The Meticulous Keyed ISAAC Authentication checks
	ensure that the Auth Key matches the expected value.  If
	either check fails, the packet MUST be silently discarded.</t>

	<t>Performing such an attack would require:</t>

	<list>
	  <t>An on-path active attack.</t>

	  <t>The attacker has the contents of one or more packets.</t>

	  <t>The attacker has managed to deduce the ISAAC key is able
	  to correlate the Sequence Number to the current ISAAC
	  state.</t>
	</list>

	<t>The attack is therefore limited to keeping the BFD session
	up when it would otherwise drop.</t>

	<t>However, the usual actual attack which we are protecting
	BFD from is availability.  That is, the attacker is trying to
	shut down then connection when the attacked parties are trying
	to keep it up.  As a result, the attacks here seem to be
	irrelevant in practice.</t>
      </section>

      <section title="Re-Use of keys">
	<t>The strength of the Auth-Type methods is significantly
	different between the strong one like SHA-1 and ISAAC.  While
	ISAAC has had cryptanalysis, and has not been shown to be
	broken, that analysis is limited. The question then is whether
	or not it is safe to use the same key for both Auth Type
	methods (SHA1 and ISAAC), or should we require different
	keys for each method?</t>

	<t>If we recommend different keys, then it is possible for the
	two keys to be configured differently on each side of a BFD
	link.  For example, a correctly configured key could allow to
	the BFD state machine to advance to Up.  Then when the session
	switches to using to weaker Auth Type with a different key,
	that key may not match, and the session would immediatly drop.
	Requiring instead that the keys be identical means that no
	such misconfiguration is possible.</t>

	<t>We believe that the use of the same key is acceptable, as
	ISAAC is keyed not only with the authentication key, but also
	depends on 32 bits of random data, along with 32 bits of a
	Sequence Number.  The use of this added randomness increases
	the difficulty of breaking the key, and makes off-line
	dictionary attacks infeasible.</t>
      </section>

    </section>

    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>The authors would like to thank Jeff Haas and Reshad Rahman
      for their reviews of and suggestions for the document.</t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include="reference.RFC.2119.xml"?>

      <?rfc include='reference.RFC.5880.xml'?>
      <?rfc include='reference.I-D.ietf-bfd-optimizing-authentication.xml'?>
    </references>

    <references title="Informative References">
      <reference anchor="ISAAC">
	<front>
	  <title>ISAAC</title>
	  <author initials="R. J." surname="Jenkins" fullname="Robert J. Jenkins Jr."/>
	  <date year="1996"/>
	</front>
	<refcontent>http://www.burtleburtle.net/bob/rand/isaac.html</refcontent>
      </reference>

      <reference anchor="ISAAC+">
	<front>
	  <title>On the pseudo-random generator ISAAC</title>
	  <author initials="J-P." surname="Aumasson" fullname="Jean-Philippe Aumasson"/>
	  <date year="2006"/>
	</front>
	<refcontent>https://eprint.iacr.org/2006/438.pdf</refcontent>
      </reference>

    </references>
  </back>
</rfc>
